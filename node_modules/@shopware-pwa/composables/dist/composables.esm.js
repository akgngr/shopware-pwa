// packages/composables/src/index.ts
import {
  markRaw,
  effectScope,
  reactive as reactive8,
  isVue2
} from "vue-demi";

// packages/composables/src/devtools/plugin.ts
import { setupDevtoolsPlugin } from "@vue/devtools-api";
import { unref } from "vue-demi";
var TIMELINE_EVENT_LAYER_ID = "shopware:events";
var INSPECTOR_ID = "shopware";
var shopwareSymbol = Symbol("shopware");
function registerShopwareDevtools(app, shopwarePluginInstance) {
  let devtoolsApi;
  let trackId = 0;
  let currentSharedState = null;
  setupDevtoolsPlugin({
    id: "shopware-pwa",
    label: "Shopware PWA",
    logo: "https://shopware.com/media/unknown/2d/80/8c/shopware_signet_blue.svg",
    packageName: "shopware-pwa",
    homepage: "shopware.com",
    app,
    enableEarlyProxy: true
  }, (api) => {
    devtoolsApi = api;
    api.addTimelineLayer({
      id: TIMELINE_EVENT_LAYER_ID,
      label: `Shopware PWA`,
      color: 1613567
    });
    api.addInspector({
      id: INSPECTOR_ID,
      label: "Shopware PWA",
      icon: "shopping_cart"
    });
    api.on.getInspectorTree((payload) => {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        payload.rootNodes = [
          {
            id: "shared-state",
            label: "Shared state"
          },
          {
            id: "interceptors",
            label: "Interceptors"
          },
          {
            id: "api-client",
            label: "API client"
          },
          {
            id: "api-defaults",
            label: "API defaults"
          }
        ];
      }
    });
    function displayState(state) {
      if (!state)
        return null;
      const res = {};
      Object.keys(state).forEach((refKey) => {
        res[refKey] = unref(currentSharedState[refKey]);
      });
      return res;
    }
    api.on.getInspectorState((payload) => {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        switch (payload.nodeId) {
          case "api-client":
            payload.state = {
              config: shopwarePluginInstance.apiInstance.config
            };
            break;
          case "shared-state":
            payload.state = {
              store: displayState(currentSharedState) || shopwarePluginInstance.state.sharedStore || payload.app.$sharedStore
            };
            break;
          case "interceptors":
            payload.state = {
              registered: shopwarePluginInstance.state.interceptors
            };
            break;
          case "api-defaults":
            payload.state = shopwarePluginInstance.state.shopwareDefaults;
            break;
          default:
            payload.state = {};
            break;
        }
      }
    });
  });
  const devtools = {
    trackEvent: (label, params) => {
      const groupId = "track" + trackId++;
      const log = (label2, params2) => {
        devtoolsApi.addTimelineEvent({
          layerId: TIMELINE_EVENT_LAYER_ID,
          event: {
            time: Date.now(),
            data: {
              label: label2,
              params: params2
            },
            title: label2,
            groupId
          }
        });
      };
      log(label, params);
      return {
        log
      };
    },
    log: (label, params) => {
      devtoolsApi.addTimelineEvent({
        layerId: TIMELINE_EVENT_LAYER_ID,
        event: {
          time: Date.now(),
          data: {
            label,
            params
          },
          title: label
        }
      });
    },
    warning: (label, params) => {
      devtoolsApi.addTimelineEvent({
        layerId: TIMELINE_EVENT_LAYER_ID,
        event: {
          time: Date.now(),
          data: {
            label,
            params
          },
          title: label,
          logType: "warning"
        }
      });
    },
    error: (label, params) => {
      devtoolsApi.addTimelineEvent({
        layerId: TIMELINE_EVENT_LAYER_ID,
        event: {
          time: Date.now(),
          data: {
            label,
            params
          },
          title: label,
          logType: "error"
        }
      });
    },
    _internal: {
      updateSharedState: (state) => {
        currentSharedState = state;
        devtoolsApi.sendInspectorState(INSPECTOR_ID);
      }
    }
  };
  return devtools;
}

// packages/composables/src/hooks/useCms/index.ts
import { computed, provide, inject, unref as unref2 } from "vue-demi";
import { getCmsPage } from "@shopware-pwa/shopware-6-client";
import { _parseUrlQuery, getCmsEntityByType } from "@shopware-pwa/helpers";
import merge from "lodash/merge";
function useCms(params) {
  const COMPOSABLE_NAME = "useCms";
  const { isVueComponent } = useVueContext();
  const cmsContext = params?.cmsContextName || isVueComponent && inject("swCmsContext", null);
  isVueComponent && provide("swCmsContext", cmsContext);
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const cacheKey = cmsContext ? `${contextName}(cms-${cmsContext})` : contextName;
  const { sharedRef } = useSharedState();
  const _searchPath = sharedRef(`${cacheKey}-searchPath`);
  const _cmsError = sharedRef(`${cacheKey}-cmsError`, null);
  const _cmsLoading = sharedRef(`${cacheKey}-cmsLoading`, false);
  const _storePage = sharedRef(`${cacheKey}-page`);
  const { getDefaults } = useDefaults({ defaultsKey: COMPOSABLE_NAME });
  const { setBreadcrumbs } = useBreadcrumbs();
  const page = computed(() => _storePage.value);
  const resourceIdentifier = computed(() => {
    return page.value?.resourceIdentifier || null;
  });
  const getEntityObject = computed(() => getCmsEntityByType(unref2(_storePage)) || {});
  const pageTitle = computed(() => getEntityObject.value.translated?.name);
  const metaTitle = computed(() => getEntityObject.value.translated?.metaTitle);
  const metaDescription = computed(() => getEntityObject.value.translated?.metaDescription);
  const metaKeywords = computed(() => getEntityObject.value.translated?.keywords);
  const search = async (path, query) => {
    _cmsLoading.value = true;
    _cmsError.value = null;
    _searchPath.value = path;
    const criteria = _parseUrlQuery(query);
    const searchCriteria = merge({}, getDefaults(), criteria);
    try {
      const result = await getCmsPage(path, searchCriteria, apiInstance);
      _storePage.value = result;
      result?.breadcrumb && setBreadcrumbs(Object.values(result.breadcrumb));
    } catch (e) {
      const err = e;
      _cmsError.value = err;
      _storePage.value = null;
    } finally {
      _cmsLoading.value = false;
    }
  };
  return {
    page,
    loading: computed(() => _cmsLoading.value || false),
    search,
    currentSearchPathKey: computed(() => _searchPath.value),
    error: computed(() => _cmsError.value),
    resourceType: computed(() => page.value?.resourceType || null),
    resourceIdentifier,
    metaTitle,
    metaDescription,
    metaKeywords,
    pageTitle
  };
}

// packages/composables/src/hooks/useProduct/index.ts
import { ref, unref as unref3 } from "vue-demi";
import { getProduct, getCmsPage as getCmsPage2 } from "@shopware-pwa/shopware-6-client";
var NO_PRODUCT_REFERENCE_ERROR = "Associations cannot be loaded for undefined product";
function useProduct(params) {
  const COMPOSABLE_NAME = "useProduct";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { getAssociationsConfig, getIncludesConfig } = useDefaults({
    defaultsKey: contextName
  });
  const loading = ref(false);
  const product = ref(unref3(params?.product) || null);
  const error = ref(null);
  const loadAssociations = async () => {
    if (!product || !product.value || !product.value.id) {
      throw NO_PRODUCT_REFERENCE_ERROR;
    }
    const searchCriteria = {
      includes: getIncludesConfig(),
      associations: getAssociationsConfig()
    };
    const urlPath = `detail/${product.value.parentId || product.value.id}`;
    const result = await getCmsPage2(urlPath, searchCriteria, apiInstance);
    product.value = Object.assign({}, product.value, {
      crossSellings: result.product?.crossSellings
    });
  };
  const search = async (productId) => {
    loading.value = true;
    try {
      const result = await getProduct(productId, null, apiInstance);
      product.value = result?.product;
      return result;
    } catch (e) {
      const err = e;
      error.value = err.messages;
    } finally {
      loading.value = false;
    }
  };
  return {
    product,
    loading,
    search,
    error,
    loadAssociations
  };
}

// packages/composables/src/hooks/useCart/index.ts
import { ref as ref2, computed as computed2 } from "vue-demi";
import {
  getCart,
  addProductToCart,
  addPromotionCode,
  removeCartItem,
  changeCartItemQuantity,
  getProducts
} from "@shopware-pwa/shopware-6-client";

// packages/commons/src/warning.ts
function warning({
  packageName,
  methodName,
  notes
}) {
  process.env.NODE_ENV !== "production" && console.warn(`[WARNING][@shopware-pwa/${packageName}][${methodName}]: ${notes}`);
}

// packages/commons/compatibility.json
var shopwareApiVersion = "6.4";
var instances = {
  "6.3": {
    domain: "https://pwa-demo-api.shopware.com/prev/",
    apiKey: "SWSC40-LJTNO6COUEN7CJMXKLA"
  },
  "6.4": {
    domain: "https://pwa-demo-api.shopware.com/trunk/",
    apiKey: "SWSC40-LJTNO6COUEN7CJMXKLA"
  },
  canary: {
    domain: "https://pwa-demo-api.shopware.com/trunk/",
    apiKey: "SWSC40-LJTNO6COUEN7CJMXKLA"
  }
};
var docVersions = [
  {
    text: "CHANGELOG",
    link: "https://github.com/vuestorefront/shopware-pwa/blob/master/CHANGELOG.md"
  },
  {
    text: "current",
    link: "https://shopware-pwa-docs.vuestorefront.io"
  },
  {
    text: "v0.10",
    link: "https://v0.10.shopware-pwa-docs.vuestorefront.io"
  },
  {
    text: "v0.9",
    link: "https://v0.9.shopware-pwa-docs.vuestorefront.io"
  }
];
var compatibility_default = {
  shopwareApiVersion,
  instances,
  docVersions
};

// packages/commons/src/defaultConfig.ts
import merge2 from "lodash/merge";
import axios from "axios";
var defaultPwaConfigFile = {
  shopwareEndpoint: compatibility_default.instances[compatibility_default.shopwareApiVersion].domain,
  shopwareAccessToken: compatibility_default.instances[compatibility_default.shopwareApiVersion].apiKey,
  theme: "@shopware-pwa/default-theme",
  shopwareApiClient: {
    timeout: 1e4
  }
};

// packages/composables/src/internalHelpers/errorHandler.ts
var broadcastErrors = (errors, methodName, broadcast) => {
  if (!Array.isArray(errors) || !errors.length || !methodName) {
    return;
  }
  errors.forEach((error) => {
    let interceptorKey;
    switch (error.level) {
      case 0 /* NOTICE */:
        interceptorKey = INTERCEPTOR_KEYS.NOTICE;
        break;
      case 10 /* WARNING */:
        interceptorKey = INTERCEPTOR_KEYS.WARNING;
        break;
      default:
        interceptorKey = INTERCEPTOR_KEYS.ERROR;
    }
    broadcast(interceptorKey, {
      methodName,
      inputParams: {},
      [interceptorKey]: error
    });
  });
};

// packages/composables/src/hooks/useCart/index.ts
function useCart() {
  const COMPOSABLE_NAME = "useCart";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { broadcast } = useIntercept();
  const { getDefaults } = useDefaults({
    defaultsKey: COMPOSABLE_NAME
  });
  const loading = ref2(false);
  const error = ref2(null);
  const { sharedRef } = useSharedState();
  const _storeCart = sharedRef(`${contextName}-cart`);
  async function refreshCart() {
    loading.value = true;
    try {
      const result = await getCart(apiInstance);
      broadcastUpcomingErrors(result);
      _storeCart.value = result;
    } catch (e) {
      const err = e;
      error.value = err.messages;
    } finally {
      loading.value = false;
    }
  }
  async function addProduct({
    id,
    quantity
  }) {
    const addToCartResult = await addProductToCart(id, quantity, apiInstance);
    broadcastUpcomingErrors(addToCartResult);
    _storeCart.value = addToCartResult;
    return addToCartResult;
  }
  async function removeItem({ id }) {
    const result = await removeCartItem(id, apiInstance);
    broadcastUpcomingErrors(result);
    _storeCart.value = result;
  }
  async function changeProductQuantity({ id, quantity }) {
    const result = await changeCartItemQuantity(id, quantity, apiInstance);
    broadcastUpcomingErrors(result);
    _storeCart.value = result;
  }
  async function submitPromotionCode(promotionCode) {
    if (promotionCode) {
      const result = await addPromotionCode(promotionCode, apiInstance);
      broadcastUpcomingErrors(result);
      _storeCart.value = result;
      broadcast(INTERCEPTOR_KEYS.ADD_PROMOTION_CODE, {
        result,
        promotionCode
      });
    }
  }
  function broadcastUpcomingErrors(cartResult) {
    if (!cartResult) {
      return;
    }
    try {
      const cartErrorsKeys = Object.keys(_storeCart.value?.errors || {});
      const cartResultErrorKeys = Object.keys(cartResult.errors || {});
      const upcomingErrorsKeys = cartResultErrorKeys.filter((resultErrorKey) => !cartErrorsKeys.includes(resultErrorKey));
      const entityErrors = Object.values(cartResult.errors || {}).filter((entityError) => entityError.level === 20 /* ERROR */ || upcomingErrorsKeys.includes(entityError.key));
      broadcastErrors(entityErrors, `[${contextName}][cartError]`, broadcast);
    } catch (error2) {
      console.error("[useCart][broadcastUpcomingErrors]", error2);
    }
  }
  async function getProductItemsSeoUrlsData() {
    if (!cartItems.value.length) {
      return [];
    }
    try {
      const result = await getProducts({
        ids: cartItems.value.map(({ referencedId }) => referencedId).filter(String),
        includes: getDefaults().getProductItemsSeoUrlsData.includes,
        associations: getDefaults().getProductItemsSeoUrlsData.associations
      }, apiInstance);
      return result?.elements || [];
    } catch (error2) {
      console.error("[useCart][getProductItemsSeoUrlsData]", error2.messages);
    }
    return [];
  }
  const appliedPromotionCodes = computed2(() => {
    return cartItems.value.filter((cartItem) => cartItem.type === "promotion");
  });
  const cart = computed2(() => _storeCart.value);
  const cartItems = computed2(() => {
    return cart.value ? cart.value.lineItems || [] : [];
  });
  const count = computed2(() => {
    return cartItems.value.reduce((accumulator, lineItem) => lineItem.type === "product" ? lineItem.quantity + accumulator : accumulator, 0);
  });
  const totalPrice = computed2(() => {
    const cartPrice = cart.value && cart.value.price && cart.value.price.totalPrice;
    return cartPrice || 0;
  });
  const shippingTotal = computed2(() => {
    const shippingTotal2 = cart.value?.deliveries?.[0]?.shippingCosts?.totalPrice;
    return shippingTotal2 || 0;
  });
  const subtotal = computed2(() => {
    const cartPrice = cart.value?.price?.positionPrice;
    return cartPrice || 0;
  });
  const cartErrors = computed2(() => cart.value?.errors && Object.values(cart.value.errors) || []);
  return {
    addProduct,
    addPromotionCode: submitPromotionCode,
    appliedPromotionCodes,
    cart,
    cartItems,
    changeProductQuantity,
    count,
    error: computed2(() => error.value),
    loading: computed2(() => loading.value),
    refreshCart,
    removeItem,
    totalPrice,
    shippingTotal,
    subtotal,
    cartErrors,
    getProductItemsSeoUrlsData,
    broadcastUpcomingErrors
  };
}

// packages/composables/src/logic/useCartItem.ts
import { computed as computed3 } from "vue-demi";
import {
  removeCartItem as removeCartItem2,
  changeCartItemQuantity as changeCartItemQuantity2,
  getProduct as getProduct2
} from "@shopware-pwa/shopware-6-client";
import { getProductMainImageUrl } from "@shopware-pwa/helpers";
function useCartItem({
  cartItem,
  qtySteps = 50
}) {
  if (!cartItem) {
    throw new Error("[useCartItem] mandatory cartItem argument is missing.");
  }
  const COMPOSABLE_NAME = "useCartitem";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { refreshCart, broadcastUpcomingErrors } = useCart();
  const { getDefaults } = useDefaults({
    defaultsKey: COMPOSABLE_NAME
  });
  const itemQuantity = computed3(() => cartItem.quantity);
  const itemImageThumbnailUrl = computed3(() => getProductMainImageUrl(cartItem));
  const itemRegularPrice = computed3(() => cartItem.price?.listPrice?.price || cartItem.price?.unitPrice);
  const itemSpecialPrice = computed3(() => cartItem.price?.listPrice && cartItem.price.unitPrice);
  const itemOptions = computed3(() => cartItem.type === "product" && cartItem.payload?.options || []);
  const itemStock = computed3(() => cartItem.deliveryInformation?.stock);
  const itemType = computed3(() => cartItem.type);
  const isProduct = computed3(() => cartItem.type === "product");
  const isPromotion = computed3(() => cartItem.type === "promotion");
  const getProductQtySteps = computed3(() => {
    const quantityInformation = cartItem.quantityInformation;
    if (!quantityInformation || !quantityInformation.purchaseSteps || quantityInformation.purchaseSteps === 1)
      return null;
    const purchaseSteps = quantityInformation.purchaseSteps;
    const availableStock = quantityInformation.maxPurchase && quantityInformation.maxPurchase < qtySteps * purchaseSteps ? quantityInformation.maxPurchase : qtySteps;
    let i = purchaseSteps;
    let options = [];
    while (i <= availableStock) {
      options.push(i);
      i += purchaseSteps;
    }
    return options;
  });
  async function removeItem() {
    const result = await removeCartItem2(cartItem.id, apiInstance);
    broadcastUpcomingErrors(result);
    refreshCart();
  }
  async function changeItemQuantity(quantity) {
    const result = await changeCartItemQuantity2(cartItem.id, quantity, apiInstance);
    broadcastUpcomingErrors(result);
    refreshCart();
  }
  async function getProductItemSeoUrlData() {
    if (!cartItem.referencedId) {
      return {};
    }
    try {
      const result = await getProduct2(cartItem.referencedId, {
        includes: getDefaults().getProductItemsSeoUrlsData.includes,
        associations: getDefaults().getProductItemsSeoUrlsData.associations
      }, apiInstance);
      return result.product;
    } catch (error) {
      console.error("[useCart][getProductItemsSeoUrlsData]", error.messages);
    }
    return {};
  }
  return {
    changeItemQuantity,
    removeItem,
    getProductItemSeoUrlData,
    getProductQtySteps,
    lineItem: computed3(() => cartItem),
    itemRegularPrice,
    itemSpecialPrice,
    itemOptions,
    itemStock,
    itemQuantity,
    itemType,
    itemImageThumbnailUrl,
    isProduct,
    isPromotion
  };
}

// packages/composables/src/logic/useAddToCart.ts
import { ref as ref3, computed as computed4, unref as unref4 } from "vue-demi";
function useAddToCart(params) {
  const COMPOSABLE_NAME = "useAddToCart";
  const contextName = COMPOSABLE_NAME;
  const product = unref4(params.product);
  getApplicationContext({ contextName });
  const { addProduct, cartItems } = useCart();
  const { broadcast, intercept } = useIntercept();
  const quantity = ref3(1);
  const loading = ref3(false);
  const error = ref3(null);
  const addToCart = async () => {
    if (!product || !product.id) {
      error.value = "Product has to be passed as a composable argument and needs to have an id property.";
      return;
    }
    loading.value = true;
    error.value = null;
    if (!quantity.value)
      quantity.value = 1;
    try {
      const addToCartResponse = await addProduct({
        id: product.id,
        quantity: quantity.value
      });
      broadcast(INTERCEPTOR_KEYS.ADD_TO_CART, {
        product,
        quantity: quantity.value,
        apiResponse: addToCartResponse
      });
      quantity.value = 1;
    } catch (e) {
      const err = e;
      error.value = err;
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][addToCart]`,
        inputParams: {
          product,
          quantity: quantity.value
        },
        error: err
      });
    } finally {
      loading.value = false;
    }
  };
  const onAddToCart = (fn) => intercept(INTERCEPTOR_KEYS.ADD_TO_CART, fn);
  const getStock = computed4(() => product && product.stock);
  const getAvailableStock = computed4(() => product && product.availableStock);
  const isInCart = computed4(() => product && cartItems.value.some((item) => item.referencedId === product.id));
  return {
    addToCart,
    quantity,
    error,
    loading,
    getStock,
    getAvailableStock,
    isInCart,
    onAddToCart
  };
}

// packages/composables/src/logic/useCheckout.ts
import { computed as computed5, reactive } from "vue-demi";
import {
  getAvailableShippingMethods,
  getAvailablePaymentMethods,
  createOrder as createApiOrder
} from "@shopware-pwa/shopware-6-client";
function useCheckout() {
  const COMPOSABLE_NAME = "useCheckout";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { broadcast, intercept } = useIntercept();
  const { refreshCart } = useCart();
  const { sessionContext } = useSessionContext();
  const { sharedRef } = useSharedState();
  const storeShippingMethods = sharedRef(`${contextName}-ShippingMethods`);
  const storePaymentMethods = sharedRef(`${contextName}-PaymentMethods`);
  const loadings = reactive({
    createOrder: false
  });
  const shippingMethods = computed5(() => storeShippingMethods.value || []);
  const paymentMethods = computed5(() => storePaymentMethods.value || []);
  const onOrderPlace = (fn) => intercept(INTERCEPTOR_KEYS.ORDER_PLACE, fn);
  const getShippingMethods = async ({ forceReload } = { forceReload: false }) => {
    if (shippingMethods.value.length && !forceReload)
      return shippingMethods;
    const response = await getAvailableShippingMethods(apiInstance, {
      onlyAvailable: true
    });
    storeShippingMethods.value = response?.elements || [];
    return shippingMethods;
  };
  const getPaymentMethods = async ({ forceReload } = { forceReload: false }) => {
    if (paymentMethods.value.length && !forceReload)
      return paymentMethods;
    const response = await getAvailablePaymentMethods(apiInstance, {
      onlyAvailable: true
    });
    storePaymentMethods.value = response?.elements || [];
    return paymentMethods;
  };
  const createOrder = async (params) => {
    try {
      loadings.createOrder = true;
      const order = await createApiOrder(params, apiInstance);
      broadcast(INTERCEPTOR_KEYS.ORDER_PLACE, {
        order
      });
      return order;
    } catch (e) {
      const err = e;
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][createOrder]`,
        inputParams: {},
        error: err
      });
      throw err;
    } finally {
      loadings.createOrder = false;
      refreshCart();
    }
  };
  const shippingAddress = computed5(() => sessionContext.value?.shippingLocation?.address);
  const billingAddress = computed5(() => sessionContext.value?.customer?.activeBillingAddress);
  return {
    getPaymentMethods,
    paymentMethods,
    getShippingMethods,
    shippingMethods,
    createOrder,
    shippingAddress,
    billingAddress,
    onOrderPlace,
    loadings
  };
}

// packages/composables/src/logic/useSessionContext.ts
import { computed as computed6 } from "vue-demi";
import {
  getSessionContext,
  setCurrentShippingMethod,
  setCurrentCurrency,
  setCurrentPaymentMethod,
  setCurrentShippingAddress,
  setCurrentBillingAddress
} from "@shopware-pwa/shopware-6-client";
function useSessionContext() {
  const COMPOSABLE_NAME = "useSessionContext";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { broadcast, intercept } = useIntercept();
  const { sharedRef } = useSharedState();
  const storeSessionContext = sharedRef(`${contextName}-sessionContext`);
  const onCurrencyChange = (fn) => intercept(INTERCEPTOR_KEYS.SESSION_SET_CURRENCY, fn);
  const onPaymentMethodChange = (fn) => intercept(INTERCEPTOR_KEYS.SESSION_SET_PAYMENT_METHOD, fn);
  const onShippingMethodChange = (fn) => intercept(INTERCEPTOR_KEYS.SESSION_SET_SHIPPING_METHOD, fn);
  const sessionContext = computed6(() => storeSessionContext.value);
  const refreshSessionContext = async () => {
    try {
      const context = await getSessionContext(apiInstance);
      storeSessionContext.value = context;
    } catch (e) {
      console.error("[UseSessionContext][refreshSessionContext]", e);
    }
  };
  const shippingMethod = computed6(() => sessionContext.value?.shippingMethod || null);
  const setShippingMethod = async (shippingMethod2 = {}) => {
    if (!shippingMethod2?.id) {
      throw new Error("You need to provide shipping method id in order to set shipping method.");
    }
    await setCurrentShippingMethod(shippingMethod2.id, apiInstance);
    await refreshSessionContext();
    broadcast(INTERCEPTOR_KEYS.SESSION_SET_SHIPPING_METHOD, {
      shippingMethod: shippingMethod2
    });
  };
  const paymentMethod = computed6(() => sessionContext.value?.paymentMethod || null);
  const setPaymentMethod = async (paymentMethod2 = {}) => {
    if (!paymentMethod2?.id) {
      throw new Error("You need to provide payment method id in order to set payment method.");
    }
    await setCurrentPaymentMethod(paymentMethod2.id, apiInstance);
    await refreshSessionContext();
    broadcast(INTERCEPTOR_KEYS.SESSION_SET_PAYMENT_METHOD, {
      paymentMethod: paymentMethod2
    });
  };
  const currency = computed6(() => sessionContext.value?.currency || null);
  const setCurrency = async (currency2 = {}) => {
    if (!currency2.id) {
      console.error("You need to provide currency id in order to set currency.", currency2);
      return;
    }
    await setCurrentCurrency(currency2.id, apiInstance);
    await refreshSessionContext();
    broadcast(INTERCEPTOR_KEYS.SESSION_SET_CURRENCY, {
      currency: currency2
    });
  };
  const activeShippingAddress = computed6(() => sessionContext.value?.customer?.activeShippingAddress || null);
  const setActiveShippingAddress = async (address) => {
    if (!address?.id) {
      throw new Error("You need to provide address id in order to set the address.");
    }
    await setCurrentShippingAddress(address.id, apiInstance);
    refreshSessionContext();
  };
  const activeBillingAddress = computed6(() => sessionContext.value?.customer?.activeBillingAddress || null);
  const setActiveBillingAddress = async (address) => {
    if (!address?.id) {
      throw new Error("You need to provide address id in order to set the address.");
    }
    await setCurrentBillingAddress(address.id, apiInstance);
    refreshSessionContext();
  };
  const countryId = computed6(() => sessionContext.value?.salesChannel?.countryId);
  return {
    sessionContext,
    refreshSessionContext,
    shippingMethod,
    setShippingMethod,
    paymentMethod,
    setPaymentMethod,
    currency,
    setCurrency,
    activeShippingAddress,
    setActiveShippingAddress,
    activeBillingAddress,
    setActiveBillingAddress,
    countryId,
    onCurrencyChange,
    onPaymentMethodChange,
    onShippingMethodChange
  };
}

// packages/composables/src/logic/useUIState.ts
import { computed as computed7, ref as ref4, unref as unref5 } from "vue-demi";
function useUIState(params) {
  const COMPOSABLE_NAME = "useUIState";
  const contextName = COMPOSABLE_NAME;
  const stateName = unref5(params?.stateName);
  getApplicationContext({ contextName });
  const { sharedRef } = useSharedState();
  const _sharedState = sharedRef(`sw-${contextName}-${stateName}`);
  const localState = ref4(false);
  const isOpen = computed7(() => stateName ? !!_sharedState.value : !!localState.value);
  function switchState(to) {
    if (stateName) {
      const stateToChange = to !== void 0 ? !!to : !_sharedState.value;
      _sharedState.value = stateToChange;
    } else {
      const stateToChange = to !== void 0 ? !!to : !localState.value;
      localState.value = stateToChange;
    }
  }
  return {
    isOpen,
    switchState
  };
}

// packages/composables/src/hooks/useCurrency.ts
import { computed as computed8 } from "vue-demi";
import { getAvailableCurrencies } from "@shopware-pwa/shopware-6-client";
function useCurrency() {
  const COMPOSABLE_NAME = "useCurrency";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { sharedRef } = useSharedState();
  const _availableCurrencies = sharedRef(`sw-${contextName}-availableCurrencies`);
  const { currency, setCurrency: setContextCurrency } = useSessionContext();
  const { refreshCart } = useCart();
  const currencySymbol = computed8(() => currency.value?.symbol || "");
  const availableCurrencies = computed8(() => {
    if (_availableCurrencies.value?.length) {
      return _availableCurrencies.value;
    }
    return currency.value ? [currency.value] : [];
  });
  const loadAvailableCurrencies = async (options) => {
    if (!options?.forceReload && _availableCurrencies.value?.length)
      return;
    const response = await getAvailableCurrencies(apiInstance);
    _availableCurrencies.value = response;
  };
  const setCurrency = async (currency2) => {
    try {
      await setContextCurrency(currency2);
      refreshCart();
    } catch (e) {
      console.error("[useCurrency][setCurrency] Problem with currency change", e);
    }
  };
  return {
    loadAvailableCurrencies,
    setCurrency,
    availableCurrencies,
    currencySymbol,
    currency
  };
}

// packages/composables/src/hooks/useNavigation.ts
import { computed as computed9 } from "vue-demi";
import { getStoreNavigation } from "@shopware-pwa/shopware-6-client";
function useNavigation(params) {
  const COMPOSABLE_NAME = "useNavigation";
  const contextName = COMPOSABLE_NAME;
  const type = params?.type || "main-navigation";
  const { apiInstance } = getApplicationContext({ contextName });
  const { sharedRef } = useSharedState();
  const { getIncludesConfig, getAssociationsConfig } = useDefaults({
    defaultsKey: contextName
  });
  const sharedElements = sharedRef(`useNavigation-${type}`);
  const navigationElements = computed9(() => sharedElements.value);
  const loadNavigationElements = async ({ depth }) => {
    try {
      const navigationResponse = await getStoreNavigation({
        requestActiveId: type,
        requestRootId: type,
        searchCriteria: {
          includes: getIncludesConfig(),
          associations: getAssociationsConfig()
        },
        depth
      }, apiInstance);
      sharedElements.value = navigationResponse || [];
    } catch (e) {
      sharedElements.value = [];
      console.error("[useNavigation][loadNavigationElements]", e.messages);
    }
  };
  return {
    navigationElements,
    loadNavigationElements
  };
}

// packages/composables/src/hooks/useSalutations.ts
import { ref as ref5, computed as computed10, onMounted } from "vue-demi";
import { getAvailableSalutations } from "@shopware-pwa/shopware-6-client";
function useSalutations() {
  const COMPOSABLE_NAME = "useSalutations";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { sharedRef } = useSharedState();
  const _salutations = sharedRef(`sw-${contextName}-salutations`);
  const error = ref5(null);
  const fetchSalutations = async () => {
    try {
      const { elements } = await getAvailableSalutations(apiInstance);
      _salutations.value = elements;
    } catch (e) {
      const err = e;
      error.value = err.messages;
    }
  };
  const mountedCallback = async () => {
    if (!_salutations.value) {
      await fetchSalutations();
    }
  };
  const getSalutations = computed10(() => {
    return _salutations.value || [];
  });
  onMounted(mountedCallback);
  return {
    mountedCallback,
    fetchSalutations,
    getSalutations,
    error
  };
}

// packages/composables/src/hooks/useCountries.ts
import { computed as computed11, ref as ref6, onMounted as onMounted2 } from "vue-demi";
import { getAvailableCountries } from "@shopware-pwa/shopware-6-client";
function useCountries() {
  const COMPOSABLE_NAME = "useCountries";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { sharedRef } = useSharedState();
  const _sharedCountried = sharedRef(`sw-${contextName}-countries`);
  const error = ref6(null);
  const fetchCountries = async () => {
    try {
      const { elements } = await getAvailableCountries(apiInstance);
      _sharedCountried.value = elements;
    } catch (e) {
      const err = e;
      error.value = err.messages;
    }
  };
  const getCountries = computed11(() => {
    return _sharedCountried.value ?? [];
  });
  const mountedCallback = async () => {
    if (!_sharedCountried.value) {
      await fetchCountries();
    }
  };
  onMounted2(mountedCallback);
  return {
    mountedCallback,
    fetchCountries,
    getCountries,
    error
  };
}

// packages/composables/src/hooks/useUser.ts
import { ref as ref7, computed as computed12, reactive as reactive2 } from "vue-demi";
import {
  login as apiLogin,
  logout as apiLogout,
  register as apiRegister,
  updateEmail as apiUpdateEmail,
  getCustomer,
  getUserCountry,
  getUserSalutation,
  updateProfile,
  setDefaultCustomerPaymentMethod
} from "@shopware-pwa/shopware-6-client";
function useUser() {
  const COMPOSABLE_NAME = "useUser";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { broadcast, intercept } = useIntercept();
  const { refreshSessionContext } = useSessionContext();
  const { refreshCart } = useCart();
  const { getDefaults } = useDefaults({ defaultsKey: contextName });
  const { sharedRef } = useSharedState();
  const storeUser = sharedRef(`${contextName}-user`);
  const loading = ref7(false);
  const error = ref7(null);
  const errors = reactive2({
    login: [],
    register: [],
    resetPassword: [],
    updatePassword: [],
    updateEmail: [],
    setDefaultPaymentMethod: []
  });
  const country = ref7(null);
  const salutation = ref7(null);
  const user = computed12(() => storeUser.value);
  async function login({
    username,
    password
  } = {}) {
    loading.value = true;
    error.value = null;
    errors.login = [];
    try {
      await apiLogin({ username, password }, apiInstance);
      await refreshUser();
      broadcast(INTERCEPTOR_KEYS.USER_LOGIN, {
        user: user.value
      });
      return true;
    } catch (e) {
      const err = e;
      errors.login = err.messages;
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][login]`,
        inputParams: {},
        error: err
      });
      return false;
    } finally {
      loading.value = false;
      await refreshUser();
      refreshCart();
    }
  }
  async function register(params) {
    loading.value = true;
    errors.register = [];
    try {
      const customer = await apiRegister(params, apiInstance);
      broadcast(INTERCEPTOR_KEYS.USER_REGISTER, { customer });
      storeUser.value = customer || {};
      refreshSessionContext();
      return true;
    } catch (e) {
      const err = e;
      errors.register = err.messages;
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][register]`,
        inputParams: {},
        error: err
      });
      return false;
    } finally {
      loading.value = false;
    }
  }
  async function logout() {
    try {
      await apiLogout(apiInstance);
      broadcast(INTERCEPTOR_KEYS.USER_LOGOUT);
    } catch (e) {
      const err = e;
      error.value = err.messages;
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][logout]`,
        inputParams: {},
        error: err
      });
    } finally {
      await refreshUser();
      refreshCart();
    }
  }
  const onLogout = (fn) => intercept(INTERCEPTOR_KEYS.USER_LOGOUT, fn);
  const onUserLogin = (fn) => intercept(INTERCEPTOR_KEYS.USER_LOGIN, fn);
  const onUserRegister = (fn) => intercept(INTERCEPTOR_KEYS.USER_REGISTER, fn);
  async function refreshUser(params = {}) {
    try {
      const user2 = await getCustomer(Object.assign({}, getDefaults(), params), apiInstance);
      storeUser.value = user2 || {};
    } catch (e) {
      storeUser.value = {};
      console.error("[useUser][refreshUser]", e);
    }
  }
  async function loadCountry(userId) {
    try {
      country.value = await getUserCountry(userId, apiInstance);
    } catch (e) {
      const err = e;
      error.value = err.messages;
    }
  }
  async function loadSalutation(salutationId) {
    try {
      salutation.value = await getUserSalutation(salutationId, apiInstance);
    } catch (e) {
      const err = e;
      error.value = err.messages;
    }
  }
  async function updatePersonalInfo(personals) {
    try {
      await updateProfile(personals, apiInstance);
    } catch (e) {
      error.value = e;
      return false;
    }
    return true;
  }
  async function updateEmail(updateEmailData) {
    errors.updateEmail = [];
    try {
      await apiUpdateEmail(updateEmailData, apiInstance);
    } catch (e) {
      errors.updateEmail = e.messages;
      return false;
    }
    return true;
  }
  async function setDefaultPaymentMethod(paymentMethodId) {
    try {
      await setDefaultCustomerPaymentMethod(paymentMethodId);
    } catch (error2) {
      errors.setDefaultPaymentMethod = error2.messages;
    }
  }
  const isLoggedIn = computed12(() => !!user.value?.id && !!user.value.active);
  const isCustomerSession = computed12(() => !!user.value?.id && !user.value.guest);
  const isGuestSession = computed12(() => !!user.value?.guest);
  return {
    login,
    register,
    user,
    error: computed12(() => error.value),
    loading: computed12(() => loading.value),
    isLoggedIn,
    isCustomerSession,
    isGuestSession,
    refreshUser,
    logout,
    updateEmail,
    updatePersonalInfo,
    setDefaultPaymentMethod,
    loadSalutation,
    salutation,
    loadCountry,
    country,
    errors,
    onLogout,
    onUserLogin,
    onUserRegister
  };
}

// packages/composables/src/hooks/useCustomerOrders.ts
import { ref as ref8, reactive as reactive3, computed as computed13 } from "vue-demi";
import {
  getCustomerOrders,
  getOrderDetails as apiGetOrderDetails
} from "@shopware-pwa/shopware-6-client";
function useCustomerOrders() {
  const COMPOSABLE_NAME = "useCustomerOrders";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { getDefaults } = useDefaults({ defaultsKey: contextName });
  const errors = reactive3({
    loadOrders: []
  });
  const ordersResult = ref8(null);
  const loadOrders = async (parameters = {}) => {
    const fetchedOrders = await getCustomerOrders(Object.assign({}, getDefaults(), parameters), apiInstance);
    ordersResult.value = fetchedOrders;
  };
  const getTotal = computed13(() => {
    const aggregations = ordersResult.value?.aggregations;
    return aggregations?.["count-id"]?.count || 0;
  });
  const getLimit = computed13(() => {
    return ordersResult.value?.limit || 10;
  });
  const getTotalPagesCount = computed13(() => Math.ceil(getTotal.value / getLimit.value));
  const orders = computed13(() => ordersResult.value?.elements || []);
  const getCurrentPage = computed13(() => ordersResult.value?.page || 1);
  const changeCurrentPage = async (pageNumber) => {
    await loadOrders({ page: +pageNumber });
  };
  const getOrderDetails2 = async (orderId, params) => apiGetOrderDetails(orderId, params, apiInstance);
  return {
    orders,
    getCurrentPage,
    changeCurrentPage,
    getTotalPagesCount,
    getTotal,
    getLimit,
    loadOrders,
    getOrderDetails: getOrderDetails2,
    errors
  };
}

// packages/composables/src/hooks/useCustomerPassword.ts
import { reactive as reactive4 } from "vue-demi";
import {
  updatePassword as apiUpdatePassword,
  resetPassword as apiResetPassword
} from "@shopware-pwa/shopware-6-client";
function useCustomerPassword() {
  const COMPOSABLE_NAME = "useCustomerPassword";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const errors = reactive4({
    resetPassword: [],
    updatePassword: []
  });
  const updatePassword = async (updatePasswordData) => {
    try {
      errors.updatePassword = [];
      await apiUpdatePassword(updatePasswordData, apiInstance);
    } catch (e) {
      errors.updatePassword = e.messages;
      return false;
    }
    return true;
  };
  const resetPassword = async (resetPasswordData) => {
    try {
      await apiResetPassword(resetPasswordData, apiInstance);
    } catch (e) {
      errors.resetPassword = e.messages;
      return false;
    }
    return true;
  };
  return {
    updatePassword,
    resetPassword,
    errors
  };
}

// packages/composables/src/hooks/useCustomerAddresses.ts
import { computed as computed14, reactive as reactive5 } from "vue-demi";
import {
  getCustomerAddresses,
  setDefaultCustomerBillingAddress,
  setDefaultCustomerShippingAddress,
  deleteCustomerAddress,
  createCustomerAddress,
  updateCustomerAddress
} from "@shopware-pwa/shopware-6-client";
function useCustomerAddresses() {
  const COMPOSABLE_NAME = "useCustomerAddresses";
  const contextName = COMPOSABLE_NAME;
  const { apiInstance } = getApplicationContext({ contextName });
  const { getDefaults } = useDefaults({ defaultsKey: contextName });
  const { refreshUser } = useUser();
  const { sharedRef } = useSharedState();
  const storeAddresses = sharedRef(`${contextName}-addresses`, []);
  const errors = reactive5({
    markAddressAsDefault: [],
    updateAddress: [],
    addAddress: [],
    deleteAddress: [],
    loadAddresses: []
  });
  const addresses = computed14(() => storeAddresses.value || []);
  const markAddressAsDefault = async ({
    addressId,
    type
  }) => {
    if (!addressId || !type) {
      return false;
    }
    try {
      switch (type) {
        case "billing":
          await setDefaultCustomerBillingAddress(addressId, apiInstance);
          break;
        case "shipping":
          await setDefaultCustomerShippingAddress(addressId, apiInstance);
          break;
        default:
          return false;
      }
      await refreshUser();
    } catch (e) {
      const err = e;
      errors.markAddressAsDefault = err.messages;
      return false;
    }
    return true;
  };
  const updateAddress = async (params) => {
    try {
      const { id } = await updateCustomerAddress(params, apiInstance);
      return id;
    } catch (e) {
      const err = e;
      errors.updateAddress = err.messages;
    }
  };
  const addAddress = async (params) => {
    try {
      const { id } = await createCustomerAddress(params, apiInstance);
      return id;
    } catch (e) {
      const err = e;
      errors.addAddress = err.messages;
    }
  };
  const deleteAddress = async (addressId) => {
    try {
      await deleteCustomerAddress(addressId, apiInstance);
      return true;
    } catch (e) {
      const err = e;
      errors.deleteAddress = err.messages;
    }
    return false;
  };
  const loadAddresses = async (params = {}) => {
    try {
      const response = await getCustomerAddresses(Object.assign({}, getDefaults(), params), apiInstance);
      storeAddresses.value = response.elements;
    } catch (e) {
      const err = e;
      errors.loadAddresses = err.messages;
    }
  };
  return {
    addresses,
    errors,
    loadAddresses,
    markAddressAsDefault,
    addAddress,
    updateAddress,
    deleteAddress
  };
}

// packages/composables/src/logic/useDefaults.ts
function useDefaults(params) {
  const COMPOSABLE_NAME = "useDefaults";
  const contextName = COMPOSABLE_NAME;
  const defaultsKey = params.defaultsKey;
  const { shopwareDefaults } = getApplicationContext({ contextName });
  if (!shopwareDefaults) {
    throw new Error("[composables][useDefaults]: applicationContext does not have shopwareDefaults!");
  }
  const getDefaultsFor = (keyName) => {
    if (!shopwareDefaults[keyName]) {
      warning({
        packageName: "composables",
        methodName: contextName,
        notes: `there is no defaults configuration for key: ${keyName}`
      });
      return;
    }
    return shopwareDefaults[keyName];
  };
  const getIncludesConfig = () => getDefaultsFor(defaultsKey)?.includes || {};
  const getAssociationsConfig = () => getDefaultsFor(defaultsKey)?.associations || {};
  const getDefaults = () => getDefaultsFor(defaultsKey) || {};
  return {
    getIncludesConfig,
    getAssociationsConfig,
    getDefaults
  };
}

// packages/composables/src/logic/useNotifications.ts
import { computed as computed15 } from "vue-demi";
function useNotifications() {
  const COMPOSABLE_NAME = "useNotifications";
  const contextName = COMPOSABLE_NAME;
  getApplicationContext({ contextName });
  const { sharedRef } = useSharedState();
  const _notifications = sharedRef(`sw-${contextName}-notifications`, []);
  const removeOne = (notificationId) => {
    _notifications.value = _notifications.value?.filter(({ id }) => id !== notificationId) || [];
  };
  const removeAll = () => _notifications.value = [];
  const geterateId = () => new Date().getTime();
  const pushNotification = async (message, options) => {
    const timeout = options.timeout || 2500;
    const persistent = !!options.persistent;
    _notifications.value = _notifications.value || [];
    const messageId = geterateId();
    _notifications.value.push({
      id: messageId,
      type: options.type,
      message
    });
    if (!persistent) {
      setTimeout(() => {
        removeOne(messageId);
      }, timeout);
    }
  };
  return {
    removeOne,
    removeAll,
    pushInfo: (message, options = {}) => pushNotification(message, { ...options, type: "info" }),
    pushSuccess: (message, options = {}) => pushNotification(message, { ...options, type: "success" }),
    pushWarning: (message, options = {}) => pushNotification(message, { ...options, type: "warning" }),
    pushError: (message, options = {}) => pushNotification(message, { ...options, type: "danger" }),
    notifications: computed15(() => _notifications.value || [])
  };
}

// packages/composables/src/logic/useIntercept.ts
import { getCurrentInstance, onUnmounted } from "vue-demi";
var INTERCEPTOR_KEYS = {
  ADD_TO_CART: "addToCart",
  ADD_TO_WISHLIST: "addToWishlist",
  ADD_PROMOTION_CODE: "addPromotionCode",
  ERROR: "error",
  WARNING: "warning",
  NOTICE: "notice",
  ORDER_PLACE: "onOrderPlace",
  ORDER_PAYMENT_METHOD_CHANGED: "onOrderPaymentMethodChanged",
  ORDER_CANCELLED: "onOrderCanceled",
  ORDER_DETAILS_LOADED: "onOrderDetailsLoaded",
  ORDER_HANDLE_PAYMENT: "onOrderHandlePayment",
  SESSION_SET_CURRENCY: "onCurrencyChange",
  SESSION_SET_PAYMENT_METHOD: "onPaymentMethodChange",
  SESSION_SET_SHIPPING_METHOD: "onShippingMethodChange",
  USER_LOGOUT: "onUserLogout",
  USER_LOGIN: "onUserLogin",
  USER_REGISTER: "onUserRegister"
};
function useIntercept() {
  const COMPOSABLE_NAME = "useIntercept";
  const contextName = COMPOSABLE_NAME;
  const { interceptors, devtools } = getApplicationContext({ contextName });
  const localSubscribers = [];
  const isVueInstance = !!getCurrentInstance();
  const broadcast = (broadcastKey, value) => {
    const event = devtools?.trackEvent("[useIntercept][broadcast] " + broadcastKey, value);
    if (interceptors[broadcastKey]?.length) {
      interceptors[broadcastKey].forEach((interceptor) => {
        event?.log("Run interceptor: " + interceptor.name, value);
        interceptor.handler(value);
      });
    }
    event?.log("Broadcast ended", value);
  };
  const intercept = (broadcastKey, handler) => {
    devtools?.warning("[useIntercept][intercept] Anonymous interceptor registration for key: " + broadcastKey + " use 'on' method instead");
    on({
      broadcastKey,
      name: "annonymous",
      handler
    });
  };
  const disconnect = (broadcastKey, interceptor) => {
    devtools?.log("[useIntercept][disconnect] Disconnecting interceptor", {
      broadcastKey,
      interceptor
    });
    interceptors[broadcastKey] = interceptors[broadcastKey]?.filter((registeredInterceptor) => registeredInterceptor.handler !== interceptor && registeredInterceptor.name !== interceptor) || [];
  };
  function on(params) {
    devtools?.log("[useIntercept][on] Registered interceptor", params);
    if (!interceptors[params.broadcastKey])
      interceptors[params.broadcastKey] = [];
    interceptors[params.broadcastKey].push({
      name: params.name,
      handler: params.handler
    });
    localSubscribers.push({
      broadcastKey: params.broadcastKey,
      name: params.name
    });
  }
  isVueInstance && onUnmounted(() => {
    localSubscribers.forEach(({ broadcastKey, name }) => {
      disconnect(broadcastKey, name);
    });
  });
  return {
    broadcast,
    intercept,
    disconnect,
    on
  };
}

// packages/composables/src/internalHelpers/defaultApiParams.json
var useCms2 = {
  limit: 10,
  associations: {
    manufacturer: {
      associations: {
        media: {}
      }
    },
    media: {
      sort: [
        {
          field: "position",
          order: "ASC",
          naturalSorting: false
        }
      ]
    },
    productReviews: {},
    properties: {
      associations: {
        group: {}
      }
    }
  },
  includes: {
    cms_page_slot: [
      "id",
      "type",
      "slot",
      "blockId",
      "config",
      "data",
      "backgroundMediaMode",
      "backgroundMedia"
    ],
    cms_page_block: [
      "slots",
      "type",
      "id",
      "backgroundColor",
      "backgroundMedia",
      "sectionPosition"
    ],
    cms_page_section: [
      "id",
      "backgroundMedia",
      "blocks",
      "type",
      "sizingMode"
    ],
    cms_page: ["id", "name", "sections", "type", "config"],
    product: [
      "media",
      "productReviews",
      "name",
      "description",
      "ratingAverage",
      "calculatedCheapestPrice",
      "calculatedPrice",
      "calculatedPrices",
      "calculatedListingPrice",
      "cover",
      "parentId",
      "id",
      "translated",
      "optionIds",
      "properties",
      "manufacturer",
      "seoUrls",
      "crossSellings",
      "availableStock",
      "customFields",
      "stock",
      "metaTitle",
      "metaDescription",
      "metaKeywords",
      "purchaseSteps"
    ],
    product_media: ["media"],
    media: ["thumbnails", "width", "height", "url"],
    media_thumbnail: ["url", "width", "height", "id"],
    calculated_price: ["unitPrice", "quantity", "listPrice"],
    product_group_option: ["id", "group", "translated", "name"],
    product_group: ["id", "translated", "name"],
    product_listing: [
      "sorting",
      "currentFilters",
      "elements",
      "page",
      "limit",
      "sortings",
      "availableSortings",
      "total",
      "aggregations"
    ],
    property_group: ["id", "translated", "options", "name", "displayType"],
    property_group_option: [
      "translated",
      "name",
      "id",
      "colorHexCode",
      "media",
      "group"
    ],
    product_manufacturer: ["translated", "link", "name", "id"]
  }
};
var useProductListing = {
  limit: 10,
  includes: {
    product: [
      "name",
      "ratingAverage",
      "calculatedCheapestPrice",
      "calculatedPrice",
      "calculatedPrices",
      "calculatedListingPrice",
      "cover",
      "id",
      "translated",
      "options",
      "seoUrls"
    ],
    product_media: ["media"],
    media: ["thumbnails", "width", "height", "url"],
    calculated_price: ["unitPrice", "quantity", "listPrice"],
    product_group_option: ["name", "id", "group", "translated"],
    product_group: ["id", "name", "options", "translated"],
    property_group: ["id", "translated", "options", "name"],
    property_group_option: [
      "translated",
      "name",
      "id",
      "colorHexCode",
      "media",
      "group"
    ]
  }
};
var useProductReviews = {
  sort: [
    {
      field: "createdAt",
      order: "desc"
    }
  ]
};
var useProductQuickSearch = {
  limit: 10,
  includes: {
    calculated_price: ["unitPrice", "quantity", "listPrice"]
  }
};
var useListing = {
  limit: 10,
  includes: {
    product: [
      "name",
      "ratingAverage",
      "calculatedPrice",
      "calculatedPrices",
      "calculatedListingPrice",
      "calculatedCheapestPrice",
      "cover",
      "id",
      "translated",
      "options",
      "seoUrls"
    ],
    product_media: ["media"],
    media: ["thumbnails", "width", "height", "url"],
    calculated_price: ["unitPrice", "quantity", "listPrice"],
    product_group_option: ["name", "id", "group", "translated"],
    product_group: ["id", "name", "options", "translated"],
    property_group: ["id", "translated", "options", "name"],
    property_group_option: [
      "name",
      "translated",
      "id",
      "colorHexCode",
      "media",
      "group"
    ]
  }
};
var useProduct2 = {
  associations: {
    crossSellings: {
      associations: {
        assignedProducts: {
          associations: {
            product: {
              associations: {
                media: {},
                cover: {},
                seoUrls: {}
              }
            }
          }
        }
      }
    },
    media: {
      sort: [
        {
          field: "position",
          order: "ASC",
          naturalSorting: false
        }
      ]
    }
  },
  includes: {
    product: [
      "name",
      "ratingAverage",
      "calculatedPrice",
      "calculatedPrices",
      "calculatedListingPrice",
      "cover",
      "id",
      "parentId",
      "translated",
      "media",
      "seoUrls",
      "crossSellings",
      "availableStock",
      "customFields"
    ],
    product_media: ["media"],
    media: ["url"],
    media_thumbnail: ["url", "width", "height", "id"],
    calculated_price: ["unitPrice", "quantity", "listPrice"],
    product_group_option: ["name", "id", "group", "translated"],
    product_group: ["id", "name", "translated"]
  }
};
var useNavigation2 = {
  associations: {
    media: {},
    seoUrls: {}
  },
  includes: {
    category: [
      "seoUrls",
      "externalLink",
      "name",
      "id",
      "children",
      "translated",
      "type",
      "media"
    ],
    seo_url: ["pathInfo", "seoPathInfo"]
  }
};
var useOrderDetails = {
  limit: 1,
  includes: {
    calculated_price: ["unitPrice", "quantity", "listPrice"]
  },
  associations: {
    lineItems: {},
    addresses: {},
    transactions: {
      sort: "-createdAt",
      associations: {
        paymentMethod: {}
      }
    },
    deliveries: {
      associations: {
        shippingMethod: {}
      }
    }
  }
};
var useCustomerOrders2 = {
  limit: 10,
  aggregations: [
    {
      name: "count-id",
      type: "count",
      field: "id"
    }
  ],
  sort: [
    {
      field: "createdAt",
      order: "desc"
    }
  ],
  associations: {},
  includes: {
    order: [
      "id",
      "orderNumber",
      "amountTotal",
      "orderDateTime",
      "stateMachineState",
      "translated"
    ],
    state_machine_state: ["id", "technicalName", "name", "translated"]
  }
};
var useCustomerAddresses2 = {
  associations: {
    salutation: {}
  },
  includes: {
    customer_address: [
      "firstName",
      "lastName",
      "city",
      "zipcode",
      "country",
      "countryId",
      "id",
      "phoneNumber",
      "state",
      "salutation",
      "salutationId",
      "street"
    ],
    country: ["name", "id", "translated"],
    salutation: ["salutationKey", "displayName", "translated", "id"]
  }
};
var useUser2 = {
  associations: {
    salutation: {},
    addresses: {}
  },
  includes: {
    customer: [
      "active",
      "doubleOptInRegistration",
      "doubleOptInConfirmDate",
      "id",
      "salutation",
      "firstName",
      "lastName",
      "email",
      "guest",
      "addresses",
      "defaultBillingAddressId",
      "defaultShippingAddressId",
      "orderCount"
    ]
  }
};
var useCart2 = {
  includes: {},
  associations: {},
  getProductItemsSeoUrlsData: {
    includes: {
      product: ["id", "seoUrls"],
      seo_url: ["seoPathInfo"]
    },
    associations: {
      seoUrls: {}
    }
  }
};
var defaultApiParams_default = {
  useCms: useCms2,
  useProductListing,
  useProductReviews,
  useProductQuickSearch,
  useListing,
  useProduct: useProduct2,
  useNavigation: useNavigation2,
  useOrderDetails,
  useCustomerOrders: useCustomerOrders2,
  useCustomerAddresses: useCustomerAddresses2,
  useUser: useUser2,
  useCart: useCart2
};

// packages/composables/src/getDefaultApiParams.ts
function getDefaultApiParams() {
  return defaultApiParams_default;
}

// packages/composables/src/logic/useListing.ts
import {
  getCategoryProducts,
  searchProducts
} from "@shopware-pwa/shopware-6-client";
import { inject as inject2, computed as computed16 } from "vue-demi";
function useListing2(params) {
  const COMPOSABLE_NAME = "useListing";
  const contextName = COMPOSABLE_NAME;
  const listingType = params?.listingType || "categoryListing";
  const { getDefaults } = useDefaults({ defaultsKey: contextName });
  const { apiInstance } = getApplicationContext({ contextName });
  let searchMethod;
  if (listingType === "productSearchListing") {
    searchMethod = async (searchCriteria) => {
      return searchProducts(searchCriteria, apiInstance);
    };
  } else {
    const { resourceIdentifier: defaultIdentifier } = useCms();
    const { isVueComponent } = useVueContext();
    const cmsPage = isVueComponent && inject2("cms-page") || null;
    const resourceIdentifier = computed16(() => cmsPage?.value?.resourceIdentifier ?? defaultIdentifier.value);
    searchMethod = async (searchCriteria) => {
      if (!resourceIdentifier.value) {
        throw new Error("[useListing][search] Search category id does not exist.");
      }
      return getCategoryProducts(resourceIdentifier.value, searchCriteria, apiInstance);
    };
  }
  return createListingComposable({
    listingKey: listingType,
    searchMethod,
    searchDefaults: getDefaults()
  });
}

// packages/composables/src/logic/useProductQuickSearch.ts
import { searchSuggestedProducts } from "@shopware-pwa/shopware-6-client";
import { ref as ref9 } from "vue-demi";
function useProductQuickSearch2() {
  const COMPOSABLE_NAME = "useProductQuickSearch";
  const contextName = COMPOSABLE_NAME;
  const { getDefaults } = useDefaults({ defaultsKey: contextName });
  const { apiInstance } = getApplicationContext({ contextName });
  const searchTerm = ref9("");
  const listingKey = "productQuickSearch";
  const searchMethod = async (searchCriteria) => {
    return searchSuggestedProducts(searchCriteria, apiInstance);
  };
  const listingComposable = createListingComposable({
    listingKey,
    searchMethod,
    searchDefaults: getDefaults()
  });
  const search = async (additionalCriteria = {}) => {
    const searchCriteria = {
      query: searchTerm.value,
      ...additionalCriteria
    };
    return listingComposable.search(searchCriteria, {
      preventRouteChange: true
    });
  };
  return {
    searchTerm,
    loading: listingComposable.loading,
    search,
    loadMore: listingComposable.loadMore,
    getProducts: listingComposable.getElements,
    getTotal: listingComposable.getTotal
  };
}

// packages/composables/src/factories/createListingComposable.ts
import { getListingFilters } from "@shopware-pwa/helpers";
import { computed as computed17, inject as inject3, ref as ref10 } from "vue-demi";
import merge3 from "lodash/merge";
function createListingComposable({
  searchMethod,
  searchDefaults,
  listingKey
}) {
  const COMPOSABLE_NAME = "createListingComposable";
  const contextName = COMPOSABLE_NAME;
  const { router } = getApplicationContext({ contextName });
  const { isVueComponent } = useVueContext();
  const cmsContext = isVueComponent && inject3("swCmsContext", null);
  const cacheKey = cmsContext ? `${contextName}(cms-${cmsContext})` : contextName;
  const loading = ref10(false);
  const loadingMore = ref10(false);
  const { sharedRef } = useSharedState();
  const _storeInitialListing = sharedRef(`${cacheKey}-initialListing-${listingKey}`);
  const _storeAppliedListing = sharedRef(`${cacheKey}-appliedListing-${listingKey}`);
  const getInitialListing = computed17(() => _storeInitialListing.value);
  const setInitialListing = async (initialListing) => {
    if (initialListing?.currentFilters?.manufacturer?.length || initialListing?.currentFilters?.properties?.length) {
      loading.value = true;
      const allFiltersResult = await searchMethod({
        query: initialListing.currentFilters.search || void 0
      });
      initialListing = Object.assign({}, initialListing, {
        aggregations: allFiltersResult?.aggregations
      });
    }
    _storeInitialListing.value = initialListing;
    _storeAppliedListing.value = null;
    loading.value = false;
  };
  const initSearch = async (criteria) => {
    loading.value = true;
    try {
      const searchCriteria = merge3({}, searchDefaults, criteria);
      const result = await searchMethod(searchCriteria);
      await setInitialListing(result);
    } catch (e) {
      throw e;
    } finally {
      loading.value = false;
    }
  };
  const search = async (criteria, options) => {
    loading.value = true;
    const changeRoute = options?.preventRouteChange !== true && !cmsContext;
    try {
      changeRoute && router.replace({
        query: {
          ...criteria
        }
      }).catch(() => {
      });
      const searchCriteria = merge3({}, searchDefaults, criteria);
      const result = await searchMethod(searchCriteria);
      const allFiltersResult = await searchMethod({
        query: searchCriteria.query,
        includes: { product_listing: ["aggregations"] }
      });
      _storeAppliedListing.value = Object.assign({}, result, {
        aggregations: Object.assign({}, result?.aggregations, allFiltersResult?.aggregations)
      });
    } catch (e) {
      throw e;
    } finally {
      loading.value = false;
    }
  };
  const loadMore = async () => {
    loadingMore.value = true;
    try {
      const query = {
        ...router.currentRoute.query,
        p: getCurrentPage.value + 1
      };
      const searchCriteria = merge3({}, searchDefaults, query);
      const result = await searchMethod(searchCriteria);
      _storeAppliedListing.value = {
        ...getCurrentListing.value,
        page: result.page,
        elements: [
          ...getCurrentListing.value?.elements || [],
          ...result.elements
        ]
      };
    } catch (e) {
      throw e;
    } finally {
      loadingMore.value = false;
    }
  };
  const getCurrentListing = computed17(() => {
    return _storeAppliedListing.value || getInitialListing.value;
  });
  const getElements = computed17(() => {
    return getCurrentListing.value?.elements || [];
  });
  const getTotal = computed17(() => {
    return getCurrentListing.value?.total || 0;
  });
  const getLimit = computed17(() => {
    return getCurrentListing.value?.limit || searchDefaults?.limit || 10;
  });
  const getTotalPagesCount = computed17(() => Math.ceil(getTotal.value / getLimit.value));
  const getSortingOrders = computed17(() => {
    const oldSortings = Object.values(getCurrentListing.value?.sortings || {});
    return getCurrentListing.value?.availableSortings || oldSortings;
  });
  const getCurrentSortingOrder = computed17(() => getCurrentListing.value?.sorting);
  const changeCurrentSortingOrder = async (order) => {
    const query = {
      ...router.currentRoute.query,
      order
    };
    await search(query);
  };
  const getCurrentPage = computed17(() => getCurrentListing.value?.page || 1);
  const changeCurrentPage = async (pageNumber) => {
    const query = {
      ...router.currentRoute.query,
      p: pageNumber || 1
    };
    await search(query);
  };
  const getAvailableFilters = computed17(() => {
    return getListingFilters(getCurrentListing.value?.aggregations);
  });
  const getCurrentFilters = computed17(() => {
    const currentFiltersResult = {};
    const currentFilters = {
      ...getCurrentListing.value?.currentFilters,
      ...router.currentRoute.query
    };
    Object.keys(currentFilters).forEach((objectKey) => {
      if (!currentFilters[objectKey])
        return;
      if (objectKey === "navigationId")
        return;
      if (objectKey === "price") {
        if (currentFilters[objectKey].min)
          currentFiltersResult["min-price"] = currentFilters[objectKey].min;
        if (currentFilters[objectKey].max)
          currentFiltersResult["max-price"] = currentFilters[objectKey].max;
        return;
      }
      if (objectKey === "p")
        return;
      currentFiltersResult[objectKey] = currentFilters[objectKey];
    });
    return currentFiltersResult;
  });
  return {
    getInitialListing,
    setInitialListing,
    initSearch,
    search,
    getCurrentListing,
    getElements,
    getSortingOrders,
    getCurrentSortingOrder,
    changeCurrentSortingOrder,
    getCurrentPage,
    changeCurrentPage,
    getTotal,
    getTotalPagesCount,
    getLimit,
    getAvailableFilters,
    getCurrentFilters,
    loading: computed17(() => loading.value),
    loadMore,
    loadingMore: computed17(() => loadingMore.value)
  };
}

// packages/composables/src/logic/useWishlist.ts
import { ref as ref11, computed as computed18, onMounted as onMounted3, unref as unref6 } from "vue-demi";
function useWishlist(params) {
  const COMPOSABLE_NAME = "useWishlist";
  const contextName = COMPOSABLE_NAME;
  const product = unref6(params?.product);
  const { broadcast, intercept } = useIntercept();
  getApplicationContext({ contextName });
  const { sharedRef } = useSharedState();
  const _wishlistItems = sharedRef(`sw-${contextName}-items`);
  const productId = ref11(product?.id);
  const onAddToWishlist = (fn) => intercept(INTERCEPTOR_KEYS.ADD_TO_WISHLIST, fn);
  const updateStorage = () => {
    localStorage.setItem("sw-wishlist-items", JSON.stringify(_wishlistItems.value));
  };
  const getFromStorage = () => {
    if (typeof window != "undefined" && localStorage) {
      return JSON.parse(localStorage.getItem("sw-wishlist-items") ?? "[]");
    }
  };
  onMounted3(() => {
    if (!_wishlistItems.value?.length) {
      try {
        const currentWishlist = getFromStorage();
        if (Array.isArray(currentWishlist) && currentWishlist.length) {
          _wishlistItems.value = currentWishlist || [];
        }
      } catch (error) {
        console.error("useWishlist:getFromStorage", error);
      }
    }
  });
  const removeFromWishlist = (itemId) => {
    const id = productId.value || itemId;
    if (!id) {
      return;
    }
    _wishlistItems.value = _wishlistItems.value?.filter((itemId2) => itemId2 != id) || [];
    updateStorage();
  };
  const addToWishlist = () => {
    if (!productId.value) {
      return;
    }
    _wishlistItems.value = _wishlistItems.value || [];
    if (!_wishlistItems.value.includes(productId.value)) {
      _wishlistItems.value.push(productId.value);
      updateStorage();
      broadcast(INTERCEPTOR_KEYS.ADD_TO_WISHLIST, {
        product
      });
    }
  };
  const isInWishlist = computed18(() => {
    return !!(productId.value && _wishlistItems.value?.includes(productId.value));
  });
  const clearWishlist = () => {
    _wishlistItems.value = [];
    updateStorage();
  };
  const items = computed18(() => _wishlistItems.value || []);
  const count = computed18(() => items.value.length);
  return {
    addToWishlist,
    removeFromWishlist,
    isInWishlist,
    clearWishlist,
    items,
    count,
    onAddToWishlist
  };
}

// packages/composables/src/hooks/useCountry.ts
import { computed as computed19 } from "vue-demi";
function useCountry(props) {
  const { getCountries } = useCountries();
  const countryId = props.countryId;
  const currentCountry = computed19(() => {
    if (!countryId.value)
      return null;
    return getCountries.value.find((country) => country.id === countryId.value) ?? null;
  });
  const displayState = computed19(() => {
    return currentCountry.value?.forceStateInRegistration ?? false;
  });
  const forceState = computed19(() => {
    return currentCountry.value?.forceStateInRegistration ?? false;
  });
  return {
    currentCountry,
    displayState,
    forceState
  };
}

// packages/composables/src/logic/useProductConfigurator.ts
import { ref as ref12, computed as computed20, unref as unref7, inject as inject4 } from "vue-demi";
import {
  invokePost,
  getProductEndpoint
} from "@shopware-pwa/shopware-6-client";
import { getTranslatedProperty } from "@shopware-pwa/helpers";
function useProductConfigurator(params) {
  const COMPOSABLE_NAME = "useProductConfigurator";
  const contextName = COMPOSABLE_NAME;
  const product = unref7(params.product);
  const { apiInstance } = getApplicationContext({ contextName });
  const { isVueComponent } = useVueContext();
  const { page: defaultPage } = useCms();
  const cmsPage = isVueComponent && inject4("cms-page") || null;
  const page = computed20(() => cmsPage?.value ?? defaultPage.value);
  const selected = ref12({});
  const isLoadingOptions = ref12(!!product.options?.length);
  const parentProductId = computed20(() => product.parentId);
  const getOptionGroups = computed20(() => page.value?.configurator || []);
  const findGroupCodeForOption = (optionId) => {
    const group = getOptionGroups.value.find((optionGroup) => {
      const optionFound = optionGroup.options.find((option) => option.id === optionId);
      return !!optionFound;
    });
    return getTranslatedProperty(group, "name");
  };
  product.optionIds?.forEach((optionId) => {
    const optionGroupCode = findGroupCodeForOption(optionId);
    if (optionGroupCode) {
      selected.value[optionGroupCode] = optionId;
    }
  });
  const findVariantForSelectedOptions = async (options) => {
    const filter = [
      {
        type: "equals",
        field: "parentId",
        value: parentProductId.value
      },
      ...Object.values(options || selected.value).map((id) => ({
        type: "equals",
        field: "optionIds",
        value: id
      }))
    ];
    try {
      if (apiInstance) {
        apiInstance.defaults.headers.common["sw-include-seo-urls"] = "true";
      }
      const response = await invokePost({
        address: getProductEndpoint(),
        payload: {
          limit: 1,
          filter,
          includes: {
            product: ["id", "translated", "productNumber", "seoUrls"],
            seo_url: ["seoPathInfo"]
          },
          associations: {
            seoUrls: {}
          }
        }
      }, apiInstance);
      return response?.data?.elements?.[0];
    } catch (e) {
      console.error("SwProductDetails:findVariantForSelectedOptions", e);
    }
  };
  const handleChange = async (group, option, onChangeHandled) => {
    selected.value = Object.assign({}, selected.value, {
      [group]: option
    });
    if (typeof onChangeHandled === "function") {
      await onChangeHandled();
    }
  };
  return {
    handleChange,
    findVariantForSelectedOptions,
    isLoadingOptions,
    getOptionGroups,
    getSelectedOptions: selected
  };
}

// packages/composables/src/logic/useBreadcrumbs.ts
import { computed as computed21, inject as inject5 } from "vue-demi";
function useBreadcrumbs(params) {
  const COMPOSABLE_NAME = "useBreadcrumbs";
  const contextName = COMPOSABLE_NAME;
  const { isVueComponent } = useVueContext();
  const cmsContext = isVueComponent && inject5("swCmsContext", null);
  const { i18n } = getApplicationContext({ contextName });
  const { sharedRef } = useSharedState();
  const cacheKey = cmsContext ? `${contextName}(cms-${cmsContext})` : contextName;
  const _sharedBreadcrumbs = sharedRef(`${cacheKey}-breadcrumbs`);
  const clear = () => {
    _sharedBreadcrumbs.value = [];
  };
  const setBreadcrumbs = (breadcrumbs) => {
    _sharedBreadcrumbs.value = breadcrumbs || [];
  };
  return {
    clear,
    setBreadcrumbs,
    breadcrumbs: computed21(() => {
      if (!!params?.hideHomeLink || !_sharedBreadcrumbs.value?.length)
        return _sharedBreadcrumbs.value || [];
      return [
        {
          name: i18n.t("Home"),
          path: "/"
        },
        ..._sharedBreadcrumbs.value
      ];
    })
  };
}

// packages/composables/src/logic/useProductAssociations.ts
import { ref as ref13, computed as computed22, unref as unref8 } from "vue-demi";
import {
  invokeGet,
  invokePost as invokePost2,
  getProductDetailsEndpoint
} from "@shopware-pwa/shopware-6-client";
function useProductAssociations(params) {
  const COMPOSABLE_NAME = "useProductAssociations";
  const contextName = COMPOSABLE_NAME;
  const product = unref8(params.product);
  const association = params.associationContext;
  const { apiInstance } = getApplicationContext({ contextName });
  const isLoading = ref13(false);
  const associations = ref13([]);
  const loadAssociations = async ({
    method,
    params: params2
  } = {}) => {
    isLoading.value = true;
    try {
      if (method && method === "get") {
        const response2 = await invokeGet({
          address: `${getProductDetailsEndpoint(product.id)}/${association}${params2 ? params2 : ""}`
        }, apiInstance);
        associations.value = response2?.data;
        return;
      }
      const response = await invokePost2({
        address: `${getProductDetailsEndpoint(product.id)}/${association}`,
        payload: params2
      }, apiInstance);
      associations.value = response?.data;
    } catch (error) {
      console.error("[useProductAssociations][loadAssociations][error]:", error);
    } finally {
      isLoading.value = false;
    }
  };
  return {
    isLoading: computed22(() => isLoading.value),
    productAssociations: computed22(() => associations.value || []),
    loadAssociations
  };
}

// packages/composables/src/logic/useProductReviews.ts
import { ref as ref14, reactive as reactive6, unref as unref9 } from "vue-demi";
import {
  getProductReviews,
  addProductReview
} from "@shopware-pwa/shopware-6-client";
function useProductReviews2(params) {
  const COMPOSABLE_NAME = "useProductReviews";
  const contextName = COMPOSABLE_NAME;
  const product = unref9(params.product);
  const { apiInstance } = getApplicationContext({ contextName });
  const { getDefaults } = useDefaults({ defaultsKey: contextName });
  const wasReviewSent = ref14(false);
  const isSendingReview = ref14(false);
  const errors = reactive6({
    loadProductReviews: [],
    addReview: []
  });
  const productReviews = ref14(null);
  const loadProductReviews = async (parameters = {}) => {
    try {
      const fetchedReviews = await getProductReviews(product.id, Object.assign({}, getDefaults(), parameters), apiInstance);
      productReviews.value = fetchedReviews.elements?.map(({ id, externalUser, customerId, createdAt, content, points }) => ({
        id,
        author: externalUser ? externalUser : customerId,
        date: createdAt,
        message: content,
        rating: points
      })) ?? [];
    } catch (e) {
      const err = e;
      errors.loadProductReviews = err.messages;
    }
  };
  const addReview = async (data) => {
    isSendingReview.value = true;
    try {
      await addProductReview(product.id, data, apiInstance);
      wasReviewSent.value = true;
    } catch (error) {
      console.error("[SwAddProductReview][submitForm]: ", error);
      errors.addReview = error.messages;
    }
    isSendingReview.value = false;
  };
  return {
    productReviews,
    loadProductReviews,
    wasReviewSent,
    addReview,
    isSendingReview,
    errors
  };
}

// packages/composables/src/logic/useSharedState.ts
import {
  computed as computed23,
  onServerPrefetch,
  getCurrentInstance as getCurrentInstance2,
  toRef,
  ref as ref15
} from "vue-demi";
var localSharedState = {};
function useSharedState() {
  const COMPOSABLE_NAME = "useSharedState";
  const contextName = COMPOSABLE_NAME;
  const { sharedStore, isServer, devtools } = getApplicationContext({
    contextName
  });
  if (!sharedStore)
    throw new Error(`[${COMPOSABLE_NAME}] sharedStore is not injected into Vue instance`);
  function sharedRef(uniqueKey, defaultValue) {
    if (!isServer && !localSharedState[uniqueKey]) {
      localSharedState[uniqueKey] = ref15(sharedStore[uniqueKey]);
    }
    const sharedRef2 = isServer ? toRef(sharedStore, uniqueKey) : localSharedState[uniqueKey];
    sharedRef2.value ?? (sharedRef2.value = defaultValue ?? null);
    return computed23({
      get: () => sharedRef2.value,
      set: (val) => {
        sharedRef2.value = val;
        devtools?._internal.updateSharedState(localSharedState);
      }
    });
  }
  async function preloadRef(refObject, callback) {
    if (!refObject.value) {
      if (isServer && getCurrentInstance2()) {
        onServerPrefetch(async () => {
          await callback();
        });
        return;
      }
      await callback();
    }
  }
  return {
    sharedRef,
    preloadRef
  };
}

// packages/composables/src/logic/useOrderDetails.ts
import {
  computed as computed24,
  reactive as reactive7,
  ref as ref16,
  unref as unref10
} from "vue-demi";
import {
  cancelOrder,
  changeOrderPaymentMethod,
  getOrderDetails,
  handlePayment as apiHandlePayment
} from "@shopware-pwa/shopware-6-client";
function useOrderDetails2(params) {
  const COMPOSABLE_NAME = "useOrderDetails";
  const contextName = COMPOSABLE_NAME;
  const order = unref10(params.order);
  const { apiInstance } = getApplicationContext({ contextName });
  const { getDefaults } = useDefaults({ defaultsKey: contextName });
  const { broadcast } = useIntercept();
  const { sharedRef } = useSharedState();
  const _sharedOrder = sharedRef(`sw-${contextName}-order`, order);
  const errors = reactive7({
    loadOrderDetails: [],
    handlePayment: [],
    cancel: [],
    changePaymentMethod: []
  });
  const loaders = reactive7({
    loadOrderDetails: false,
    handlePayment: false,
    cancel: false,
    changePaymentMethod: false
  });
  const orderId = order?.id;
  const paymentMethod = computed24(() => _sharedOrder.value?.transactions?.[0]?.paymentMethod);
  const shippingMethod = computed24(() => _sharedOrder.value?.deliveries?.[0]?.shippingMethod);
  const paymentUrl = ref16();
  const personalDetails = computed24(() => ({
    email: _sharedOrder.value?.orderCustomer?.email,
    firstName: _sharedOrder.value?.orderCustomer?.firstName,
    lastName: _sharedOrder.value?.orderCustomer?.lastName
  }));
  const billingAddress = computed24(() => _sharedOrder.value?.addresses?.find(({ id }) => id === _sharedOrder.value.billingAddressId));
  const shippingAddress = computed24(() => _sharedOrder.value?.deliveries?.[0]?.shippingOrderAddress);
  const shippingCosts = computed24(() => _sharedOrder.value?.shippingTotal);
  const subtotal = computed24(() => _sharedOrder.value?.price?.positionPrice);
  const total = computed24(() => _sharedOrder.value?.price?.totalPrice);
  const status = computed24(() => _sharedOrder.value?.stateMachineState?.name);
  const loadOrderDetails = async () => {
    loaders.loadOrderDetails = true;
    try {
      const orderDetailsResponse = await getOrderDetails(orderId, getDefaults(), apiInstance);
      _sharedOrder.value = orderDetailsResponse ?? null;
      broadcast(INTERCEPTOR_KEYS.ORDER_DETAILS_LOADED, _sharedOrder.value);
    } catch (e) {
      const error = e;
      errors.loadOrderDetails = error.messages;
      broadcast(INTERCEPTOR_KEYS.ERROR, error);
    }
    loaders.loadOrderDetails = false;
  };
  const handlePayment = async (finishUrl, errorUrl, paymentDetails) => {
    loaders.handlePayment = true;
    try {
      const resp = await apiHandlePayment({
        orderId,
        finishUrl,
        errorUrl,
        paymentDetails
      }, apiInstance);
      paymentUrl.value = resp?.redirectUrl;
      broadcast(INTERCEPTOR_KEYS.ORDER_HANDLE_PAYMENT, resp);
    } catch (e) {
      const error = e;
      errors.handlePayment = error.messages;
      broadcast(INTERCEPTOR_KEYS.ERROR, error);
    }
    loaders.handlePayment = false;
  };
  const cancel = async () => {
    loaders.cancel = true;
    try {
      const response = await cancelOrder(orderId, apiInstance);
      broadcast(INTERCEPTOR_KEYS.ORDER_CANCELLED, response);
    } catch (error) {
      errors.cancel = error.messages;
      broadcast(INTERCEPTOR_KEYS.ERROR, error);
    }
    loaders.cancel = false;
    await loadOrderDetails();
  };
  const changePaymentMethod = async (paymentMethodId) => {
    loaders.changePaymentMethod = true;
    try {
      await changeOrderPaymentMethod(orderId, paymentMethodId, apiInstance);
      broadcast(INTERCEPTOR_KEYS.ORDER_PAYMENT_METHOD_CHANGED, order);
    } catch (error) {
      errors.changePaymentMethod = error.messages;
      broadcast(INTERCEPTOR_KEYS.ERROR, error);
    }
    loaders.changePaymentMethod = false;
    await loadOrderDetails();
  };
  return {
    order: computed24(() => _sharedOrder.value),
    status,
    total,
    subtotal,
    shippingCosts,
    shippingAddress,
    billingAddress,
    personalDetails,
    paymentUrl,
    shippingMethod,
    paymentMethod,
    errors,
    loaders,
    loadOrderDetails,
    handlePayment,
    cancel,
    changePaymentMethod
  };
}

// packages/composables/src/getVueContext.ts
import { getCurrentInstance as getCurrentInstance3, getCurrentScope } from "vue-demi";

// packages/composables/src/internalHelpers/getContextProperty.ts
function getContextProperty(object, name) {
  return object?.[`$${name}`] || object?.[name];
}

// packages/composables/src/getVueContext.ts
function extendScopeContext(scope, app) {
  scope.vm.shopwareApiInstance = getContextProperty(app, "shopwareApiInstance");
  scope.vm.sharedStore = getContextProperty(app, "sharedStore");
  scope.vm.interceptors = getContextProperty(app, "interceptors");
  scope.vm.shopwareDefaults = getContextProperty(app, "shopwareDefaults");
  scope.vm.i18n = getContextProperty(app, "i18n");
  scope.vm.routing = getContextProperty(app, "routing");
  scope.vm.shopware = getContextProperty(app, "shopware");
}
function useVueContext() {
  const vueComponentInstance = getCurrentInstance3()?.proxy;
  const vueScopeInstance = getCurrentScope()?.vm;
  return {
    isVueComponent: !!vueComponentInstance,
    isVueScope: !!vueScopeInstance
  };
}

// packages/composables/src/appContext.ts
import {
  getCurrentInstance as getCurrentInstance4,
  getCurrentScope as getCurrentScope2,
  inject as inject6
} from "vue-demi";
function getApplicationContext(params) {
  const key = params?.contextName || "getApplicationContext";
  const injectedContext = getCurrentInstance4()?.proxy;
  const scopeContext = getCurrentScope2?.()?.vm;
  let context = scopeContext || injectedContext;
  const injectedShopwareContext = injectedContext && inject6("shopware", null);
  const shopwareContext = injectedShopwareContext || getContextProperty(context, "shopware");
  if (!shopwareContext) {
    console.warn(`[${key}] Use createShopware method to setup composables.`);
  } else {
    return {
      apiInstance: shopwareContext.apiInstance,
      router: getContextProperty(context, "router"),
      route: getContextProperty(context, "route"),
      routing: getContextProperty(context, "routing"),
      i18n: getContextProperty(context, "i18n"),
      cookies: getContextProperty(context, "cookies"),
      shopwareDefaults: shopwareContext.state.shopwareDefaults,
      interceptors: shopwareContext.state.interceptors,
      sharedStore: shopwareContext.state.sharedStore,
      devtools: shopwareContext.devtools,
      isServer: !!(getContextProperty(context, "isServer") || typeof process !== "undefined" && !!process.server),
      contextName: key
    };
  }
  return {
    apiInstance: getContextProperty(context, "shopwareApiInstance"),
    router: getContextProperty(context, "router"),
    route: getContextProperty(context, "route"),
    routing: getContextProperty(context, "routing"),
    i18n: getContextProperty(context, "i18n"),
    cookies: getContextProperty(context, "cookies"),
    shopwareDefaults: getContextProperty(context, "shopwareDefaults"),
    interceptors: getContextProperty(context, "interceptors"),
    sharedStore: getContextProperty(context, "sharedStore"),
    isServer: !!(getContextProperty(context, "isServer") || typeof process !== "undefined" && !!process.server),
    contextName: key
  };
}

// packages/composables/src/devtools/vue2.ts
var ShopwareVuePlugin = function(_Vue, pluginOptions) {
  _Vue.mixin({
    beforeCreate() {
      const options = this.$options;
      if (options.shopware) {
        const shopware = options.shopware;
        if (!this._provided) {
          const provideCache = {};
          Object.defineProperty(this, "_provided", {
            get: () => provideCache,
            set: (v) => Object.assign(provideCache, v)
          });
        }
        this._provided[shopwareSymbol] = shopware;
        if (!this.$shopware) {
          this.$shopware = shopware;
        }
        shopware._a = this;
        if (pluginOptions?.enableDevtools && typeof window !== "undefined") {
          const devtools = registerShopwareDevtools(shopware._a, shopware);
          shopware.devtools = devtools;
        }
      } else if (!this.$shopware && options.parent && options.parent.$shopware) {
        this.$shopware = options.parent.$shopware;
      }
    }
  });
};

// packages/composables/src/index.ts
function createShopware(app, options) {
  const scope = effectScope(true);
  const state = scope.run(() => {
    return reactive8({
      interceptors: {},
      sharedStore: options.initialStore || reactive8({}),
      shopwareDefaults: options.shopwareDefaults || {}
    });
  });
  const shopwarePlugin = markRaw({
    install(app2, options2) {
      if (!isVue2) {
        shopwarePlugin._a = app2;
        app2.config.globalProperties.$shopware = shopwarePlugin;
        app2.provide("shopware", shopwarePlugin);
        if (options2?.enableDevtools && typeof window !== "undefined") {
          registerShopwareDevtools(app2, shopwarePlugin);
        }
      }
    },
    _a: app,
    _e: scope,
    apiInstance: options.apiInstance,
    state
  });
  if (!isVue2 && options?.enableDevtools && typeof window !== "undefined") {
    registerShopwareDevtools(app, shopwarePlugin);
  }
  return shopwarePlugin;
}
export {
  INTERCEPTOR_KEYS,
  ShopwareVuePlugin,
  createListingComposable,
  createShopware,
  extendScopeContext,
  getApplicationContext,
  getDefaultApiParams,
  useAddToCart,
  useBreadcrumbs,
  useCart,
  useCartItem,
  useCheckout,
  useCms,
  useCountries,
  useCountry,
  useCurrency,
  useCustomerAddresses,
  useCustomerOrders,
  useCustomerPassword,
  useDefaults,
  useIntercept,
  useListing2 as useListing,
  useNavigation,
  useNotifications,
  useOrderDetails2 as useOrderDetails,
  useProduct,
  useProductAssociations,
  useProductConfigurator,
  useProductQuickSearch2 as useProductQuickSearch,
  useProductReviews2 as useProductReviews,
  useSalutations,
  useSessionContext,
  useSharedState,
  useUIState,
  useUser,
  useVueContext,
  useWishlist
};
