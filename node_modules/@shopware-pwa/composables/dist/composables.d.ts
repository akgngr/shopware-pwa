/**
 * Vue's composables to be used in Shopware frontend application.
 *
 * @packageDocumentation
 */

import { AddressType } from '@shopware-pwa/commons/interfaces';
import { ApiDefaults } from '@shopware-pwa/commons';
import { App } from 'vue-demi';
import { BillingAddress } from '@shopware-pwa/commons/interfaces';
import { Breadcrumb } from '@shopware-pwa/commons/interfaces';
import { Cart } from '@shopware-pwa/commons/interfaces';
import { CmsPageResponse } from '@shopware-pwa/commons/interfaces';
import { CmsResourceType } from '@shopware-pwa/commons/interfaces';
import { ComputedRef } from 'vue-demi';
import { Country } from '@shopware-pwa/commons/interfaces';
import { CreateOrderParams } from '@shopware-pwa/commons/interfaces';
import { CrossSelling } from '@shopware-pwa/commons/interfaces';
import { Currency } from '@shopware-pwa/commons/interfaces';
import { Customer } from '@shopware-pwa/commons/interfaces';
import { CustomerAddress } from '@shopware-pwa/commons/interfaces';
import { CustomerRegistrationParams } from '@shopware-pwa/commons/interfaces';
import { CustomerResetPasswordParam } from '@shopware-pwa/shopware-6-client';
import { CustomerUpdateEmailParam } from '@shopware-pwa/shopware-6-client';
import { CustomerUpdatePasswordParam } from '@shopware-pwa/shopware-6-client';
import { CustomerUpdateProfileParam } from '@shopware-pwa/shopware-6-client';
import { EffectScope } from 'vue-demi';
import { EntityError } from '@shopware-pwa/commons/interfaces';
import { Includes } from '@shopware-pwa/commons/interfaces';
import { LineItem } from '@shopware-pwa/commons/interfaces';
import { LineItemType } from '@shopware-pwa/commons/interfaces';
import { ListingFilter } from '@shopware-pwa/helpers';
import { ListingResult } from '@shopware-pwa/commons/interfaces';
import { Order } from '@shopware-pwa/commons/interfaces';
import { PaymentMethod } from '@shopware-pwa/commons/interfaces';
import { Product } from '@shopware-pwa/commons/interfaces';
import { PropertyGroup } from '@shopware-pwa/commons/interfaces';
import { PropertyGroupOption } from '@shopware-pwa/commons';
import { Ref } from 'vue-demi';
import { Salutation } from '@shopware-pwa/commons/interfaces';
import { SearchFilterType } from '@shopware-pwa/commons';
import { SessionContext } from '@shopware-pwa/commons/interfaces';
import { ShippingAddress } from '@shopware-pwa/commons/interfaces';
import { ShippingMethod } from '@shopware-pwa/commons/interfaces';
import { ShopwareApiInstance } from '@shopware-pwa/shopware-6-client';
import { ShopwareAssociation } from '@shopware-pwa/commons/interfaces';
import { ShopwareError } from '@shopware-pwa/commons/interfaces';
import { ShopwareSearchParams } from '@shopware-pwa/commons/interfaces';
import { Sort } from '@shopware-pwa/commons/interfaces';
import { StoreNavigationElement } from '@shopware-pwa/commons/interfaces';
import { StoreNavigationType } from '@shopware-pwa/commons/interfaces';
import { UiProductReview } from 'packages/helpers/src/ui-interfaces';
import { UnwrapRef } from 'vue-demi';
import { WritableComputedRef } from 'vue-demi';

/**
 * Factory to create your own listing. By default you can use useListing composable, which provides you predefined listings for category(cms) listing and product search listing.
 * Using factory you can provide our own compatible search method and use it for example for creating listing of orders in my account.
 *
 * @public
 */
export declare function createListingComposable<ELEMENTS_TYPE>({ searchMethod, searchDefaults, listingKey, }: {
    searchMethod: (searchParams: Partial<ShopwareSearchParams>) => Promise<ListingResult<ELEMENTS_TYPE>>;
    searchDefaults: ShopwareSearchParams;
    listingKey: string;
}): IUseListing<ELEMENTS_TYPE>;

/**
 * Create ShopwarePlugin vue instance. Shpware PWA composables rely on this config.
 *
 * @beta
 */
export declare function createShopware(app: App, options: {
    initialStore?: any;
    shopwareDefaults: ApiDefaults;
    apiInstance: ShopwareApiInstance;
    enableDevtools?: boolean;
}): {
    install(app: App, options?: {
        enableDevtools: boolean;
    }): void;
    _a: App<any>;
    _e: EffectScope;
    apiInstance: ShopwareApiInstance;
    state: {
        interceptors: {};
        sharedStore: any;
        shopwareDefaults: {
            [x: string]: {
                p?: number | undefined;
                page?: number | undefined;
                limit?: number | undefined;
                filter?: ({
                    value: string | null;
                    field: string;
                    type: SearchFilterType;
                } | {
                    value: string[];
                    field: string;
                    type: SearchFilterType;
                } | {
                    field: string;
                    parameters: {
                        lt: string | number;
                    } | {
                        gt: string | number;
                    } | {
                        lte: string | number;
                    } | {
                        gte: string | number;
                    } | {
                        lt: string | number;
                        gt: string | number;
                    } | {
                        lt: string | number;
                        gte: string | number;
                    } | {
                        lte: string | number;
                        gt: string | number;
                    } | {
                        lte: string | number;
                        gte: string | number;
                    };
                    type: SearchFilterType;
                } | {
                    operator: string;
                    queries: ({
                        value: string | null;
                        field: string;
                        type: SearchFilterType;
                    } | {
                        value: string[];
                        field: string;
                        type: SearchFilterType;
                    } | {
                        field: string;
                        parameters: {
                            lt: string | number;
                        } | {
                            gt: string | number;
                        } | {
                            lte: string | number;
                        } | {
                            gte: string | number;
                        } | {
                            lt: string | number;
                            gt: string | number;
                        } | {
                            lt: string | number;
                            gte: string | number;
                        } | {
                            lte: string | number;
                            gt: string | number;
                        } | {
                            lte: string | number;
                            gte: string | number;
                        };
                        type: SearchFilterType;
                    } | any | {
                        value: string[];
                        field: string;
                        type: SearchFilterType;
                    })[];
                    type: SearchFilterType;
                })[] | undefined;
                sort?: {
                    field: string;
                    order: string;
                    naturalSorting?: boolean | undefined;
                }[] | undefined;
                postFilter?: ({
                    value: string | null;
                    field: string;
                    type: SearchFilterType;
                } | {
                    value: string[];
                    field: string;
                    type: SearchFilterType;
                } | {
                    field: string;
                    parameters: {
                        lt: string | number;
                    } | {
                        gt: string | number;
                    } | {
                        lte: string | number;
                    } | {
                        gte: string | number;
                    } | {
                        lt: string | number;
                        gt: string | number;
                    } | {
                        lt: string | number;
                        gte: string | number;
                    } | {
                        lte: string | number;
                        gt: string | number;
                    } | {
                        lte: string | number;
                        gte: string | number;
                    };
                    type: SearchFilterType;
                } | {
                    operator: string;
                    queries: ({
                        value: string | null;
                        field: string;
                        type: SearchFilterType;
                    } | {
                        value: string[];
                        field: string;
                        type: SearchFilterType;
                    } | {
                        field: string;
                        parameters: {
                            lt: string | number;
                        } | {
                            gt: string | number;
                        } | {
                            lte: string | number;
                        } | {
                            gte: string | number;
                        } | {
                            lt: string | number;
                            gt: string | number;
                        } | {
                            lt: string | number;
                            gte: string | number;
                        } | {
                            lte: string | number;
                            gt: string | number;
                        } | {
                            lte: string | number;
                            gte: string | number;
                        };
                        type: SearchFilterType;
                    } | any | {
                        value: string[];
                        field: string;
                        type: SearchFilterType;
                    })[];
                    type: SearchFilterType;
                })[] | undefined;
                associations?: {
                    [x: string]: {
                        associations?: any | undefined;
                        sort?: string | {
                            field: string;
                            order: string;
                            naturalSorting: boolean;
                        }[] | undefined;
                    };
                } | undefined;
                aggregations?: {
                    name: string;
                    type: string;
                    field: string;
                }[] | undefined;
                grouping?: {
                    field: string;
                }[] | undefined;
                order?: string | undefined;
                term?: string | undefined;
                ids?: string[] | undefined;
                properties?: string | never[] | undefined;
                manufacturer?: string | never[] | undefined;
                includes?: {
                    [x: string]: string[];
                } | undefined;
                query?: string | undefined;
            };
        };
    } | undefined;
};

/**
 * Inject context into effect scope. Do not use this function directly, internal use only.
 *
 * @alpha
 */
export declare function extendScopeContext(scope: any, app: any): void;

/**
 * Get the current application context values. The context is either a scope or a component instance.
 * This method checks if the context contains all the necessary data.
 *
 * This method will likely change in future in order to provide full Vue3 compability.
 *
 * @beta
 */
export declare function getApplicationContext(params?: {
    contextName?: string;
}): {
    apiInstance: any;
    router: any;
    route: any;
    routing: SwRouting;
    i18n: any;
    cookies: any;
    shopwareDefaults: any;
    interceptors: any;
    sharedStore: any;
    devtools: any;
    isServer: boolean;
    contextName: string;
} | {
    apiInstance: ShopwareApiInstance;
    router: any;
    route: any;
    routing: SwRouting;
    i18n: any;
    cookies: any;
    shopwareDefaults: ApiDefaults;
    interceptors: SwInterceptors;
    sharedStore: {
        [x: string]: any;
    };
    isServer: boolean;
    contextName: string;
    devtools?: undefined;
};

/**
 * Returns default system API params
 *
 * @beta
 */
export declare function getDefaultApiParams(): {
    [composableName: string]: ShopwareSearchParams;
};

/**
 * interface for the callback function of interceptors
 * @public
 */
export declare interface IInterceptorCallbackFunction {
    (payload: any): void;
}

/**
 * Keys used accross composables with the name of incommint parameters.
 *
 * @beta
 */
export declare const INTERCEPTOR_KEYS: {
    /**
     * Broadcasted by useAddToCart composable on successful addToCart method invocation.
     * As a parameter passes product added to cart and quantity.
     */
    ADD_TO_CART: string;
    /**
     * Broadcasted by useWishlist composable on successful addToWishlist method invocation.
     * As a parameter passes:
     * - product object
     */
    ADD_TO_WISHLIST: string;
    /**
     * Broadcasted by useCart composable on successful submitPromotionCode method invocation.
     * As a parameter passes used promotion code and response result.
     */
    ADD_PROMOTION_CODE: string;
    /**
     * Broadcasted through application in case of important error.
     * Can be used to connect to external service collectiong logs.
     * As a parameter passes:
     * - methodName - string - method where error occured
     * - inputParams - Object - input params of the method
     * - error - string - message of the error
     */
    ERROR: string;
    /**
     * Broadcasted through application in case of relevant warning.
     * Can be used to inform end-user about current request's problems.
     * As a parameter passes:
     * - methodName - string - method where error occured
     * - inputParams - Object - input params of the method
     * - warning - Object - error object with specific message, like CartError object
     */
    WARNING: string;
    /**
     * Broadcasted through application in case of relevant notice message.
     * Can be used to inform end-user about current request's problems.
     * As a parameter passes:
     * - methodName - string - method where error occured
     * - inputParams - Object - input params of the method
     * - notice - Object - error object with specific message, like CartError object
     */
    NOTICE: string;
    /**
     * Broadcasted by useCheckout, createOrder method.
     * As a parameter passes:
     * - order object
     */
    ORDER_PLACE: string;
    /**
     * Broadcasted by useOrderDetauils, changePaymentMethod method.
     */
    ORDER_PAYMENT_METHOD_CHANGED: string;
    /**
     * Broadcasted by useOrderDetauils, cancel method.
     */
    ORDER_CANCELLED: string;
    /**
     * Broadcasted by useOrderDetauils, loadOrderDetails method.
     */
    ORDER_DETAILS_LOADED: string;
    /**
     * Broadcasted by useOrderDetauils, handlePayment method.
     */
    ORDER_HANDLE_PAYMENT: string;
    /**
     * Broadcasted by useSessionContext, setCurrency method.
     * As a parameter passes:
     * - currency object
     */
    SESSION_SET_CURRENCY: string;
    /**
     * Broadcasted by useSessionContext, setPaymentMethod method.
     * As a parameter passes:
     * - payment method object
     */
    SESSION_SET_PAYMENT_METHOD: string;
    /**
     * Broadcasted by useSessionContext, setShippingMethod method.
     * As a parameter passes:
     * - shipping method object
     */
    SESSION_SET_SHIPPING_METHOD: string;
    /**
     * Broadcasted after user is logged out.
     * Contains no params.
     */
    USER_LOGOUT: string;
    /**
     * Broadcasted after user is logged in.
     * As a parameter passes:
     * - customer object
     */
    USER_LOGIN: string;
    /**
     * Broadcasted after user is successfully registered.
     */
    USER_REGISTER: string;
};

/**
 * interface for {@link useAddToCart} composable
 * @beta
 */
export declare interface IUseAddToCart {
    /**
     * Add to cart method
     */
    addToCart: () => Promise<void>;
    /**
     * If you want to add more that 1 product set quantity before invoking `addToCart`
     */
    quantity: Ref<number>;
    /**
     * Adding to cart is in progress
     */
    loading: Ref<boolean>;
    /**
     * Error message when adding to cart was not successful
     */
    error: Ref<string>;
    /**
     * Returns product count in stock
     */
    getStock: Ref<number | null>;
    /**
     * Returns product count in available stock
     */
    getAvailableStock: Ref<number | null>;
    /**
     * Flag if product is already in cart
     */
    isInCart: Ref<boolean>;
    /**
     * React on product added to cart
     */
    onAddToCart: (fn: (params: {
        product: Product;
        quantity: Number;
    }) => void) => void;
}

/**
 * interface for {@link useCart} composable
 *
 * @beta
 */
export declare interface IUseCart {
    addProduct: ({ id, quantity, }: {
        id: string;
        quantity?: number;
    }) => Promise<Cart>;
    addPromotionCode: (promotionCode: string) => Promise<void>;
    appliedPromotionCodes: ComputedRef<LineItem[]>;
    cart: ComputedRef<Cart | null>;
    cartItems: ComputedRef<LineItem[]>;
    changeProductQuantity: ({ id, quantity, }: {
        id: string;
        quantity: number;
    }) => void;
    count: ComputedRef<number>;
    error: ComputedRef<string>;
    loading: ComputedRef<boolean>;
    refreshCart: () => void;
    removeItem: ({ id }: LineItem) => Promise<void>;
    totalPrice: ComputedRef<number>;
    shippingTotal: ComputedRef<number>;
    subtotal: ComputedRef<number>;
    cartErrors: ComputedRef<EntityError[]>;
    getProductItemsSeoUrlsData(): Promise<Partial<Product>[]>;
    broadcastUpcomingErrors(cart: Cart): void;
}

/**
 * interface for {@link useCartItem} composable
 *
 * @beta
 */
export declare interface IUseCartItem {
    lineItem: ComputedRef<LineItem | undefined | null>;
    itemRegularPrice: ComputedRef<number | undefined>;
    itemSpecialPrice: ComputedRef<number | undefined>;
    itemImageThumbnailUrl: ComputedRef<string>;
    itemOptions: ComputedRef<PropertyGroupOption[]>;
    itemType: ComputedRef<LineItemType | undefined>;
    isProduct: ComputedRef<boolean>;
    isPromotion: ComputedRef<boolean>;
    itemStock: ComputedRef<number | undefined>;
    itemQuantity: ComputedRef<number | undefined>;
    changeItemQuantity: (quantity: number) => Promise<void>;
    removeItem: () => Promise<void>;
    getProductItemSeoUrlData(): Promise<Partial<Product>>;
    getProductQtySteps: ComputedRef<number[] | null>;
}

/**
 * interface for {@link useCheckout} composable
 *
 * @beta
 */
export declare interface IUseCheckout {
    getShippingMethods: (options?: {
        forceReload: boolean;
    }) => Promise<ComputedRef<ShippingMethod[]>>;
    shippingMethods: ComputedRef<ShippingMethod[]>;
    getPaymentMethods: (options?: {
        forceReload: boolean;
    }) => Promise<ComputedRef<PaymentMethod[]>>;
    paymentMethods: ComputedRef<PaymentMethod[]>;
    createOrder: (params?: CreateOrderParams) => Promise<Order>;
    shippingAddress: ComputedRef<ShippingAddress | undefined>;
    billingAddress: ComputedRef<Partial<BillingAddress> | undefined>;
    onOrderPlace: (fn: (params: {
        order: Order;
    }) => void) => void;
    loadings: UnwrapRef<{
        createOrder: boolean;
    }>;
}

/**
 * @beta
 */
export declare interface IUseCountries {
    mountedCallback: () => Promise<void>;
    getCountries: ComputedRef<Country[]>;
    fetchCountries: () => Promise<void>;
    error: Ref<any>;
}

/**
 * @beta
 */
export declare interface IUseCountry {
    currentCountry: ComputedRef<Country | null>;
    displayState: ComputedRef<boolean>;
    forceState: ComputedRef<boolean>;
}

/**
 * @beta
 */
export declare interface IUseCurrency {
    loadAvailableCurrencies: (options?: {
        forceReload: boolean;
    }) => Promise<void>;
    setCurrency: (parameter: Partial<Currency>) => Promise<void>;
    availableCurrencies: ComputedRef<Currency[]>;
    currency: ComputedRef<Currency | null>;
    currencySymbol: ComputedRef<string>;
}

/**
 * interface for {@link useCustomerAddresses} composable
 *
 * @beta
 */
export declare interface IUseCustomerAddresses {
    errors: UnwrapRef<{
        markAddressAsDefault: ShopwareError[];
        loadAddresses: ShopwareError[];
        addAddress: ShopwareError[];
        updateAddress: ShopwareError[];
        deleteAddress: ShopwareError[];
    }>;
    addresses: ComputedRef<CustomerAddress[]>;
    loadAddresses: () => Promise<void>;
    addAddress: (params: Partial<CustomerAddress>) => Promise<string | undefined>;
    updateAddress: (params: Partial<CustomerAddress>) => Promise<string | undefined>;
    deleteAddress: (addressId: string) => Promise<boolean>;
    markAddressAsDefault: ({ addressId, type, }: {
        addressId?: string;
        type?: AddressType;
    }) => Promise<string | boolean>;
}

/**
 * interface for {@link useCustomerOrders} composable
 *
 * @beta
 */
export declare interface IUseCustomerOrders {
    orders: Ref<Order[] | null>;
    getTotal: ComputedRef<number>;
    getCurrentPage: ComputedRef<number>;
    getTotalPagesCount: ComputedRef<number>;
    getLimit: ComputedRef<number>;
    changeCurrentPage: (pageNumber?: number | string) => Promise<void>;
    errors: UnwrapRef<{
        loadOrders: ShopwareError[];
    }>;
    loadOrders: () => Promise<void>;
    getOrderDetails: (orderId: string) => Promise<Order | undefined>;
}

/**
 * interface for {@link useCustomerPassword} composable
 *
 * @beta
 */
export declare interface IUseCustomerPassword {
    errors: UnwrapRef<{
        resetPassword: ShopwareError[];
        updatePassword: ShopwareError[];
    }>;
    updatePassword: (updatePasswordData: CustomerUpdatePasswordParam) => Promise<boolean>;
    resetPassword: (resetPasswordData: CustomerResetPasswordParam) => Promise<boolean>;
}

/**
 * Listing interface, can be used to display category products, search products or any other Shopware search interface (ex. orders with pagination)
 *
 * @public
 */
export declare interface IUseListing<ELEMENTS_TYPE> {
    getInitialListing: ComputedRef<ListingResult<ELEMENTS_TYPE> | null>;
    setInitialListing: (initialListing: Partial<ListingResult<ELEMENTS_TYPE>>) => void;
    initSearch: (criteria: Partial<ShopwareSearchParams>) => Promise<void>;
    search: (criteria: Partial<ShopwareSearchParams>, options?: {
        preventRouteChange?: boolean;
    }) => Promise<void>;
    loadMore: () => Promise<void>;
    getCurrentListing: ComputedRef<Partial<ListingResult<ELEMENTS_TYPE>> | null>;
    getElements: ComputedRef<ELEMENTS_TYPE[]>;
    getSortingOrders: ComputedRef<Sort[] | {
        key: string;
        label: string;
    }>;
    getCurrentSortingOrder: ComputedRef<string | undefined>;
    changeCurrentSortingOrder: (order: string | string[]) => Promise<void>;
    getCurrentPage: ComputedRef<string | number>;
    changeCurrentPage: (pageNumber?: number | string) => Promise<void>;
    getTotal: ComputedRef<number>;
    getTotalPagesCount: ComputedRef<number>;
    getLimit: ComputedRef<number>;
    getAvailableFilters: ComputedRef<ListingFilter[]>;
    getCurrentFilters: ComputedRef<any>;
    loading: ComputedRef<boolean>;
    loadingMore: ComputedRef<boolean>;
}

/**
 * interface for {@link useNavigation} composable
 *
 * Provides state for navigation trees depending on navigation type.
 *
 * @beta
 */
export declare interface IUseNavigation {
    navigationElements: ComputedRef<StoreNavigationElement[] | null>;
    /**
     * Load navigation elements
     */
    loadNavigationElements: (params: {
        depth: number;
    }) => Promise<void>;
}

/**
 * @beta
 */
export declare interface IUseProduct<PRODUCT, SEARCH> {
    product: Ref<PRODUCT | null>;
    search: SEARCH;
    loading: Ref<boolean>;
    error: Ref<any>;
    [x: string]: any;
}

/**
 * interface for {@link IUseProductAssociations} composable
 * @beta
 */
export declare interface IUseProductAssociations {
    /**
     * Start loading resources
     */
    loadAssociations: (params: {
        params: unknown;
        method: "post" | "get";
    }) => Promise<void>;
    /**
     * If it's loading - indicator
     */
    isLoading: ComputedRef<boolean>;
    productAssociations: ComputedRef<CrossSelling[]>;
}

/**
 * interface for {@link useProductConfigurator} composable
 * @beta
 */
export declare interface IUseProductConfigurator {
    /**
     * Handler for action when the selected option is changed
     */
    handleChange: (attribute: string, option: string, onChangeHandled?: Function) => Promise<void>;
    findVariantForSelectedOptions: (options?: {
        [key: string]: string;
    }) => Promise<void>;
    /**
     * Indicates if the options are being (re)loaded
     */
    isLoadingOptions: Ref<boolean>;
    /**
     * Object of currently selected options
     */
    getSelectedOptions: Ref<{
        [key: string]: string;
    }>;
    /**
     * All assigned properties which the variant can be made of
     */
    getOptionGroups: Ref<PropertyGroup[]>;
}

/**
 * @beta
 */
export declare interface IUseProductQuickSearch {
    searchTerm: Ref<string>;
    loading: ComputedRef<boolean>;
    search: (additionalCriteria?: Partial<ShopwareSearchParams>) => Promise<void>;
    loadMore: () => Promise<void>;
    getProducts: ComputedRef<Product[]>;
    getTotal: ComputedRef<number>;
}

/**
 * interface for {@link useProductReviews} composable
 *
 * @beta
 */
export declare interface IUseProductReviews {
    productReviews: Ref<UiProductReview[] | null>;
    errors: UnwrapRef<{
        loadProductReviews: ShopwareError[];
        addReview: ShopwareError[];
    }>;
    wasReviewSent: Ref<boolean>;
    isSendingReview: Ref<boolean>;
    addReview: (data: {
        title: string;
        content: string;
        points: number;
    }) => Promise<void>;
    loadProductReviews: (parameters?: ShopwareSearchParams) => Promise<void>;
}

/**
 * @beta
 */
export declare interface IUseSalutations {
    mountedCallback: () => Promise<void>;
    getSalutations: ComputedRef<Salutation[]>;
    fetchSalutations: () => Promise<void>;
    error: Ref<any>;
}

/**
 * interface for {@link useSessionContext} composable
 *
 * @remarks
 * SessionContext contain all related data like user, currency, country, shippingMethod, paymentMethod etc.
 *
 * @beta
 */
export declare interface IUseSessionContext {
    sessionContext: ComputedRef<SessionContext | null>;
    refreshSessionContext: () => Promise<void>;
    shippingMethod: ComputedRef<ShippingMethod | null>;
    setShippingMethod: (shippingMethod: Partial<ShippingMethod>) => Promise<void>;
    paymentMethod: ComputedRef<PaymentMethod | null>;
    setPaymentMethod: (paymentMethod: Partial<PaymentMethod>) => Promise<void>;
    currency: ComputedRef<Currency | null>;
    setCurrency: (currency: Partial<Currency>) => Promise<void>;
    activeShippingAddress: ComputedRef<ShippingAddress | null>;
    setActiveShippingAddress: (address: Partial<ShippingAddress>) => Promise<void>;
    activeBillingAddress: ComputedRef<BillingAddress | null>;
    setActiveBillingAddress: (address: Partial<BillingAddress>) => Promise<void>;
    countryId: ComputedRef<string | undefined>;
    onCurrencyChange: (fn: (params: {
        currency: Currency;
    }) => void) => void;
    onPaymentMethodChange: (fn: (params: {
        paymentMethod: PaymentMethod;
    }) => void) => void;
    onShippingMethodChange: (fn: (params: {
        shippingMethod: ShippingMethod;
    }) => void) => void;
}

/**
 * interface for {@link useUser} composable
 *
 * @beta
 */
export declare interface IUseUser {
    login: ({ username, password, }: {
        username?: string;
        password?: string;
    }) => Promise<boolean>;
    register: ({}: CustomerRegistrationParams) => Promise<boolean>;
    user: ComputedRef<Partial<Customer> | null>;
    loading: ComputedRef<boolean>;
    error: ComputedRef<any>;
    errors: UnwrapRef<{
        [errorAlias: string]: ShopwareError[];
    }>;
    isLoggedIn: ComputedRef<boolean>;
    isCustomerSession: ComputedRef<boolean>;
    isGuestSession: ComputedRef<boolean>;
    country: Ref<Country | null>;
    salutation: Ref<Salutation | null>;
    refreshUser: () => Promise<void>;
    logout: () => Promise<void>;
    loadCountry: (countryId: string) => Promise<void>;
    loadSalutation: (salutationId: string) => Promise<void>;
    updatePersonalInfo: (personals: CustomerUpdateProfileParam) => Promise<boolean>;
    updateEmail: (updateEmailData: CustomerUpdateEmailParam) => Promise<boolean>;
    setDefaultPaymentMethod: (paymentMethodId: string) => Promise<void>;
    /**
     * React on user logout
     */
    onLogout: (fn: () => void) => void;
    onUserLogin: (fn: (params: {
        customer: Customer;
    }) => void) => void;
    onUserRegister: (fn: () => void) => void;
}

/**
 * interface for {@link useWishlist} composable
 * @beta
 */
export declare interface IUseWishlist {
    removeFromWishlist: (id: string) => void;
    clearWishlist: () => void;
    addToWishlist: () => void;
    onAddToWishlist: (fn: (params: {
        product: Product;
    }) => void) => void;
    isInWishlist: Ref<boolean>;
    items: Ref<string[]>;
    count: Ref<number>;
}

/**
 * @beta
 */
export declare type ListingType = "productSearchListing" | "categoryListing";

/**
 * @beta
 */
declare interface Notification_2 {
    type: "info" | "warning" | "success" | "danger";
    message: string;
    id?: number;
}
export { Notification_2 as Notification }

/**
 * @beta
 */
export declare type Search = (path: string, associations?: any) => any;

/**
 * @beta
 */
export declare interface ShopwareDomain {
    url: string;
    origin: string;
    host: string;
    pathPrefix: string;
    domainId: string;
    currencyId: string;
    snippetSetId: string;
    languageId: string;
    languageName: string;
    languageLabel: string;
    languageLocaleCode: string;
}

/**
 *
 * @beta
 */
export declare const ShopwareVuePlugin: (_Vue: any, pluginOptions: {
    enableDevtools: boolean;
}) => void;

/**
 * @beta
 */
export declare type SwInterceptor = {
    name: string;
    handler: IInterceptorCallbackFunction;
};

/**
 * @beta
 */
export declare type SwInterceptors = {
    [broadcastKey: string]: Array<SwInterceptor>;
};

/**
 * Routing type for Shopware SEO path resolvers
 *
 * @beta
 */
export declare type SwRouting = {
    availableDomains: ShopwareDomain[];
    fallbackDomain?: string;
    fallbackLocale?: string;
    getCurrentDomain: ComputedRef<ShopwareDomain>;
    setCurrentDomain: (domainData: any) => void;
    getUrl: (path: string) => string;
    getAbsoluteUrl: (path: string) => string;
};

/**
 * Add product to cart. Options - {@link IUseAddToCart}
 *
 * @example
 * Example usage:
 *
 * ```ts
 * const {isInCart, quantity, addToCart} = useAddToCart({ product })
 * if (!isInCart.value) {
 *    quantity.value = 5
 *    await addToCart()
 * }
 * ```
 * @beta
 */
export declare function useAddToCart(params: {
    product: Ref<Product> | Product;
}): IUseAddToCart;

/**
 * Composable for displaying and setting breadcrumbs for page.
 *
 * @beta
 */
export declare function useBreadcrumbs(params?: {
    /**
     * Define if you want to show/hide link to Home in breadcrumbs.
     *
     * By default we show Home link.
     */
    hideHomeLink: boolean;
}): {
    breadcrumbs: ComputedRef<Breadcrumb[]>;
    setBreadcrumbs: (breadcrumbs: Breadcrumb[]) => void;
    clear: () => void;
};

/**
 * Composable for cart management. Options - {@link IUseCart}
 *
 * @beta
 */
export declare function useCart(): IUseCart;

/**
 * Composable for cart item management. Options - {@link IUseCartItem}
 *
 * @beta
 */
export declare function useCartItem({ cartItem, qtySteps, }: {
    cartItem: LineItem;
    qtySteps?: number;
}): IUseCartItem;

/**
 * Composable for Checkout management. Options - {@link IUseCheckout}
 *
 * @beta
 */
export declare function useCheckout(): IUseCheckout;

/**
 * @beta
 */
export declare function useCms(params?: {
    /**
     * Additional context for CMS, use that if you need to display more that one CMS page on a single view (for example quickView).
     */
    cmsContextName?: string;
}): {
    page: ComputedRef<CmsPageResponse | null>;
    resourceType: ComputedRef<CmsResourceType | null>;
    resourceIdentifier: ComputedRef<string | null>;
    currentSearchPathKey: ComputedRef<string | null>;
    loading: Ref<boolean>;
    search: (path: string, query?: any) => Promise<void>;
    error: Ref<any>;
    metaTitle: ComputedRef<string>;
    metaDescription: ComputedRef<string>;
    metaKeywords: ComputedRef<string>;
    pageTitle: ComputedRef<string>;
};

/**
 * @beta
 */
export declare function useCountries(): IUseCountries;

/**
 * @beta
 */
export declare function useCountry(props: {
    countryId: ComputedRef<string>;
}): IUseCountry;

/**
 * @beta
 */
export declare function useCurrency(): IUseCurrency;

/**
 * Composable for user's addresses management. Options - {@link IUseCustomerAddresses}
 *
 * @beta
 */
export declare function useCustomerAddresses(): IUseCustomerAddresses;

/**
 * Composable for listing customer orders. Options - {@link IUseCustomerOrders}
 *
 * @beta
 */
export declare function useCustomerOrders(): IUseCustomerOrders;

/**
 * Composable for customer password management. Options - {@link IUseCustomerPassword}
 *
 * @beta
 */
export declare function useCustomerPassword(): IUseCustomerPassword;

/**
 * Returns default config depending on config key.
 * It is used in composables, so defaultsKey is in most cases composable name (ex. `useDefaults({ defaultsKey: "useCms" })`)
 *
 * @remarks
 * To extend defaults you need to add configuration to `shopware-pwa.config.js` file.
 * Let's say we want to add product new_option field and change listing limit on CMS pages. We need to add to configuration file:
 * ```js
 * // inside shopware-pwa.config.js
 * const defaultsConfigBuilder =
 *   require("@shopware-pwa/nuxt-module/api-defaults").default
 *`
 * defaultsConfigBuilder()
 *   .replace("useCms.limit", 8) // change default listing limit to 8
 *   .add("useCms.includes.product", "new_option") // add product new_option to returned fields
 *
 * module.exports = {
 *   // ... your standard Shopware PWA settings
 * }
 * ```
 * We need to remember the structure of includes and associations. You can read more about this {@link https://docs.shopware.com/en/shopware-platform-dev-en/admin-api-guide/reading-entities?category=shopware-platform-dev-en/admin-api-guide#parameter-overview | in shopware docs}.
 *
 * @beta
 */
export declare function useDefaults(params: {
    defaultsKey: string;
}): {
    getIncludesConfig: () => Includes;
    getAssociationsConfig: () => ShopwareAssociation;
    getDefaults: () => ShopwareSearchParams;
};

/**
 * Allows to broadcast and intercept events across application.
 *
 * @public
 */
export declare function useIntercept(): {
    broadcast: (broadcastKey: string, value?: any) => void;
    intercept: (broadcastKey: string, handler: IInterceptorCallbackFunction) => void;
    disconnect: (broadcastKey: string, interceptor: string | IInterceptorCallbackFunction) => void;
    on: (params: {
        broadcastKey: string;
        name: string;
        handler: IInterceptorCallbackFunction;
    }) => void;
};

/**
 * @beta
 */
export declare function useListing(params?: {
    listingType: ListingType;
}): IUseListing<Product>;

/**
 * Composable for navigation. Options - {@link IUseNavigation}
 *
 * @example
 * ```
 * // get main navigation
 * useNavigation()
 * // get footer navigation
 * useNavigation({ type: "footer-navigation" } )
 * ```
 *
 * @beta
 */
export declare function useNavigation(params?: {
    type?: StoreNavigationType;
}): IUseNavigation;

/**
 * @beta
 */
export declare function useNotifications(): {
    notifications: ComputedRef<Notification_2[]>;
    removeOne: (id: number) => void;
    removeAll: () => void;
    pushInfo: (message: string, options?: any) => void;
    pushWarning: (message: string, options?: any) => void;
    pushError: (message: string, options?: any) => void;
    pushSuccess: (message: string, options?: any) => void;
};

/**
 * Composable for managing an existing order.
 *
 * @beta
 */
export declare function useOrderDetails(params: {
    order: Ref<Order> | Order;
}): {
    order: ComputedRef<Order | undefined | null>;
    status: ComputedRef<string | undefined>;
    total: ComputedRef<number | undefined>;
    subtotal: ComputedRef<number | undefined>;
    shippingCosts: ComputedRef<number | undefined>;
    shippingAddress: ComputedRef<ShippingAddress | undefined>;
    billingAddress: ComputedRef<BillingAddress | undefined>;
    personalDetails: ComputedRef<{
        email: string | undefined;
        firstName: string | undefined;
        lastName: string | undefined;
    }>;
    paymentUrl: Ref<null | string>;
    shippingMethod: ComputedRef<ShippingMethod | undefined | null>;
    paymentMethod: ComputedRef<PaymentMethod | undefined | null>;
    errors: UnwrapRef<{
        [key: string]: ShopwareError[];
    }>;
    loaders: UnwrapRef<{
        [key: string]: boolean;
    }>;
    loadOrderDetails: () => void;
    handlePayment: (successUrl?: string, errorUrl?: string, paymentDetails?: unknown) => void;
    cancel: () => Promise<void>;
    changePaymentMethod: (paymentMethodId: string) => Promise<void>;
};

/**
 * @beta
 */
export declare function useProduct(params?: {
    product?: Ref<Product> | Product;
}): IUseProduct<Product, Search>;

/**
 * Get product association entity. Options - {@link IUseProductAssociations}
 *
 * @example
 * Example of possibilities:
 *
 * ```ts
 * const { loading, loadAssociations, productAssociations } = useProductAssociation({product, associationContext: "cross-selling"})
 * if (!productAssociations.value) {
 *    await loadAssociations()
 * }
 * ```
 * @beta
 */
export declare function useProductAssociations(params: {
    product: Ref<Product> | Product;
    associationContext: "cross-selling" | "reviews";
}): IUseProductAssociations;

/**
 * Product options - {@link IUseAddToCart}
 * @beta
 */
export declare function useProductConfigurator(params: {
    product: Ref<Product> | Product;
}): IUseProductConfigurator;

/**
 * @beta
 */
export declare function useProductQuickSearch(): IUseProductQuickSearch;

/**
 * Composable for listing customer orders. Options - {@link IUseProductReviews}
 *
 * @beta
 */
export declare function useProductReviews(params: {
    product: Ref<Product> | Product;
}): IUseProductReviews;

/**
 * @beta
 */
export declare function useSalutations(): IUseSalutations;

/**
 * Composable for session management. Options - {@link IUseSessionContext}
 *
 * @beta
 */
export declare function useSessionContext(): IUseSessionContext;

/**
 * Replacement for Vuex. Composable, which enables you to use shared state in your application.
 * State is shared both on server and client side.
 *
 * @public
 */
export declare function useSharedState(): {
    sharedRef: <T>(uniqueKey: string, defaultValue?: T | undefined) => WritableComputedRef<T | null>;
    preloadRef: (refObject: Ref<unknown>, callback: () => Promise<void>) => Promise<void>;
};

/**
 * Simple state management for UI purposes.
 *
 * @remarks
 * If you pase `stateName` on composable invocation (ex. `useUIState({stateName: 'sidebarCart'})`), then
 * state is shared between all instances with this key.
 * Otherwise state is local, so multiple `useUIState()` will not share state
 *
 * @example
 * ```ts
 * // Component1
 * const {isOpen, switchState} = useUIState({stateName: 'SIDEBAR_STATE'})
 * switchState()
 *
 * // Component 2
 * const {isOpen} = useUIState({stateName: 'SIDEBAR_STATE'})
 * // isOpen will be true
 * ```
 *
 * If you'll not use KEY on composable init, then state is only local
 *
 * ```ts
 * // Component1
 * const {isOpen, switchState} = useUIState()
 * switchState()
 *
 * // Component 2
 * const {isOpen} = useUIState()
 * // isOpen will be false
 * ```
 *
 * @beta
 */
export declare function useUIState(params?: {
    stateName?: Ref<string> | string;
}): {
    isOpen: ComputedRef<boolean>;
    switchState: (to?: boolean) => void;
};

/**
 * Composable for user management. Options - {@link IUseUser}
 *
 * @beta
 */
export declare function useUser(): IUseUser;

/**
 * Use Vue instance scope. Do not use this function directly, internal use only.
 *
 *
 * @alpha
 */
export declare function useVueContext(): {
    isVueComponent: boolean;
    isVueScope: boolean;
};

/**
 *
 * @beta
 */
export declare function useWishlist(params?: {
    product?: Product | Ref<Product>;
}): IUseWishlist;

export { }
